## **📗 목차**


🏆 [프로젝트 소개](#-프로젝트-소개)

👨🏻‍💻 [팀원 소개](#-팀원-소개)

🛠 [개발 도구](#-개발-도구)

⏰ [프로젝트 일정](#-프로젝트-일정)

🔗 [API명세서와 ERD설계도](#-API명세서와-ERD설계도)
  
📝 [메뉴구조도](#-메뉴구조도)
  
✨ [화면 구현 및 코드 리뷰](#-화면-구현-및-코드-리뷰)
  - [회원가입 화면 구현 영상 및 코드 리뷰](#회원가입-화면-구현-영상-및-코드-리뷰)
  - [로그인 화면 구현 영상 및 코드 리뷰](#로그인-화면-구현-영상-및-코드-리뷰)
  - [펀딩 메인 페이지 화면 구현 영상 및 코드 리뷰](#펀딩-메인-페이지-화면-구현-영상-및-코드-리뷰)
  - [펀딩 상세 페이지 화면 구현 영상 및 코드 리뷰](#펀딩-상세-페이지-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 등록 페이지 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-등록-페이지-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 수정 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-수정-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 삭제 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-삭제-화면-구현-영상-및-코드-리뷰)
  - [OAuth2 회원가입 및 로그인 화면 구현 영상 및 코드 리뷰](#OAuth2-회원가입-및-로그인-화면-구현-영상-및-코드-리뷰)
  - [OAuth2 Google, Kakao 계정 통합 화면 구현 영상 및 코드 리뷰](#OAuth2-Google-Kakao-계정-통합-화면-구현-영상-및-코드-리뷰)
  
👨🏻‍💻 [느낀점](#-느낀점)

<br/>

## **🏆 프로젝트 소개**

- 프로젝트 제목 - 펀딩 및 기부 서비스 테스트

- 프로젝트 목적 - 배운 것들을 복습 및 활용, 협업에 대한 이해

- 분류 - 팀프로젝트

- 제작 기간 - 2023.05.03 ~ 2023.06.07

<br/>

## **👨🏻‍💻 팀원 소개**

<br/>

> **팀장: 정의현** 
- 사용한 통계에 프로젝트 설계
- 펀딩페이지 CRUD 기능 구현 및 CSS
- 로그인 및 회원가입 기능 구현
- security jwt 및 accessToken 디테일 작업
- 파일 입출력
- API 명세서
- 관리자 CRUD 기능 구현
- OAuth2 로그인, 회원가입 기능 구현
- 결제 기능 구현

<br/>

> **팀원: 김수현** 
- 메인 페이지 기능 구현 및 CSS
- header 작업
- ppt 작업

<br/>

> **팀원: 김상현** 
- 기부페이지 CRUD 기능구현 및 CSS
- 로그인 회원가입 페이지 CSS
- ERD 명세서
- security jwt 및 accessToken 틀 작업

<br/>

> **팀원: 이해강** 
- 데이터 크롤링
- 검색 기능

<br/>

## **🛠 개발 도구**

<br/>

### FrontEnd

<img src="https://img.shields.io/badge/Visual Studio Code-007ACC?style=for-the-badge&logo=Visual Studio Code&logoColor=white"/> <img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> 
<img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white"> 
<img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> 
<img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black"> 

### BackEnd

<img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> <img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"> 

### 형상 관리
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white"> <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">

<br/>

***ORM: Mybatis***

<br/>

## **⏰ 프로젝트 일정**


![스크린샷(1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/4f7ea0ba-3d55-4106-9672-da1fde38a496)

<br/><br/>

**참고 웹사이트:** https://happybean.naver.com/

<br/>

## **🔗 API명세서와 ERD설계도**

### API 명세서

https://third-tempo-8c0.notion.site/4b573b520b424c3590c6ce244e1df794?v=f2f7a9bebd714ea3be176765f004f3d2

<br/>

### ERD 설계도


<div align="center">
 
 ### 펀딩 ERD
 
</div>

![KakaoTalk_20230605_153904436](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/c6a471b0-85f3-4d27-a258-0ac460f730d4)

<br/><br/>

<div align="center">
 
 ### 기부 ERD

![KakaoTalk_20230605_154821409](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/86dc51b4-dca5-4fa9-bfb5-7398474b865f)


 
</div>

<br/><br/>

## **📝 메뉴구조도**

![스크린샷(2)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/263c80b5-0421-4bb8-b7ac-96c53100b837)

<br/>

## **✨ 화면 구현 및 코드 리뷰**

<br/>

### **회원가입 화면 구현 영상 및 코드 리뷰**

<details>
<summary>이메일 유효성 검사 영상과 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![이메일 유효성 검사](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/0bf30e4f-bf10-4864-a202-cba2c63a045d)

</br></br>

## FrontEnd

<br/>

**웹에서 이메일 입력 받기**

```html

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
            <Input id="input-with-icon-adornment"
                css={placeholderFontSize}
                label="email" 
                variant="outlined" 
                placeholder="이메일 주소 입력" 
                name="email" 
                type="text" 
                onChange={onChangeHandler} 
                startAdornment={
                    <InputAdornment position="start">
                    <Mail />
                    </InputAdornment>
                } />
                {emailSubmitDisabled ? (
                successMessage.email && <Alert css={errorCss} severity="success">{successMessage.email}</Alert>
            ) : (
                <>
                    {emailErrorMessage.email && <Alert css={errorCss} severity="error">{emailErrorMessage.email}</Alert>}
                    {errorMessage.email && <Alert css={errorCss} severity="error">{errorMessage.email}</Alert>}
                </>
            )}
        </FormControl>
        <Button variant="contained" css={checkedEmail} onClick={checkedEmailSubmit}>중복확인</Button>
    </div>

```

</br>

- input 창에 이메일 입력을 받고, 중복확인 버튼도 넣어준다.
- input 창에는 onChange, button에는 onClick을 넣어줌으로써 내가 취한 행동에 대한 값을 함수로 넘겨준다.

---

</br></br>

**입력 받은 값 처리**

```javascript

const onChangeHandler = (e) => {
    const { name, value } = e.target;
    setSignUp({...signUp, [name]: value});
}

```

</br>

- name에는 email, value에는 email이라는 이름을 가진 input창에 값이 들어가있다.
- 입력 받은 값을 setSignUp(useState로 렌더링이 될 때 마다 상태가 업데이트가 된다)에 데이터를 넣어준다.

---

</br></br>

**요청**

```javascript

    const checkedEmailSubmit = () => {
        checkDuplicateEmail.mutate();
    }

```

</br>

```javascript

const checkDuplicateEmail = useMutation(async () => {
    setErrorMessages({email: ""})

    const data = {
        email: signUp.email
    }
    const option = {
        headers: {
            "Content-Type": "application/json"
        }
    }

    try {
        await axios.post("http://localhost:8080/auth/checkemail", JSON.stringify(data), option)
        setSuccessMessage({email: <div css={availableEmail}>사용 가능한 이메일입니다.</div>})
        setEmailSubmitDisabled(true);
    }catch(error) {
        setEmailErrorMessage({email: error.response.data.errorData.email})
        setEmailSubmitDisabled(false);
    }
})

```

</br>

- useMutation을 사용해 요청을 보내면 상태 관리나 에러 처리 부분에 있어서 용이하다. 그래서 get 요청을 제외하고는 useMutation을 사용하여 요청을 보내는 것이 좋다.
  get 요청에 관한 것은 아래에서 다룰 것이다. 

- Javascript는 싱글 쓰레드이기 때문에 모든 코드가 비동기 처리로 돼서 요청에서 오류가 꽤 생길 수 있다. 예를 들어, 요청에 대한 코드 바로 다음에 응답으로 받은 데이터를 가지고 처리하는 코드가 있다 치자. 서버에 데이터 요청을 보내고 나서 응답이 오지도 않음과 동시에 필요한 데이터를 받지도 못했는데 다음 코드가 실행이 되는 상황이 생겨버린다. 그래서 비동기 처리 과정을 동기적인 것처럼 실행하기 위해 async 함수와 함께 await 키워드를 쓴다. (비동기 처리가 실제 동기 처리가 되는 것이 아니고, 동기와 유사하게 보이는 것임)

- 서버로 보낸 요청 데이터를 동기적인 것처럼 실행을 하고 싶기 때문에 await 뒤에 요청 url을 넣어준다.

- input 창에서 입력 받은 값을 요청 데이터로 보낸다.

- 만약 유효성 검사에서 에러 없이 성공적으로 처리가 됐다면 "사용 가능한 이메일입니다."를 띄워준다.

- 에러가 있다면 검사해서 떴던 에러 내용을 setEmailErrorMessage에 담는다.

- setEmailSubmitDisabled에 넣어준 상태 값은 아래 회원가입 성공에 설명이 있다.
  
---

</br></br>

## BackEnd

<br/>

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class SignUpController {
	
	private final SignUpService signUpService;
	
	@ValidAspect
	@PostMapping("/checkemail")
	public ResponseEntity<?> duplicatedEmail(@Valid @RequestBody DuplicatedEmailReqDto email, BindingResult bindingResult) {
		signUpService.duplicatedEmail(email.getEmail());
		return ResponseEntity.ok().body(true);
	}
	
}

```

</br>

- 프론트에서 보낸 email을 받아준다.
- Post요청(CRUD 중 Create)에 대한 데이터 처리.
- @Valid를 달아주면 dto 안에 있는 email(), Pattern() 등을 검사해준다.
- @Valid와 BindingResult는 세트임. signUpReqDto의 오류를 BindingResult에게 모두 넘겨준다.

---

</br></br>

**Dto**

```java

@Data
public class DuplicatedEmailReqDto {
	@Email
	@NotBlank(message="이메일을 입력하세요")
	private String email;
}

```

</br>

- @Email과 @NotBlank 등 validation과 관련된 어노테이션을 써주면 거기에 해당되는 메세지를 에러 메세지로 반환해준다. 

---

</br></br>

**Service**

```java

public void duplicatedEmail(String email) {
  if(signUpRepository.findUserByEmail(email) != null) {
    throw new CustomException("Duplicated Email", 
        ErrorMap.builder()
        .put("email", "사용 중인 email입니다.")
        .build());
  }
}

```

</br>

- Controller에서 보낸 email을 받아서 데이터베이스에 있는 이메일과 비교를 한다.
- 이메일이 존재한다면 따로 만들어준 CustomException이라는 객체와 ErrorMap이라는 객체에 "email"이라는 키와 "사용 중인 email입니다."라는 value를 넣어준다.
- 이 에러 메세지를 만들어줌으로써 프론트에서 이 메세지를 처리할 수 있게 된다.

---

</br></br>

**Repository**

```java

@Mapper
public interface UserRepository {
	public User findUserByEmail(String email);
}

```

</br>

- xml file로 대체
- interface를 써야 Mapper를 쓸 수 있고, mybatis에서 받을 수 있다.
- Service에서 보낸 email을 데이터베이스로 들고가서 확인을 한다.

---

</br></br>

**Sql**

```sql

<select id="findUserByEmail" resultMap="userMap">
  select
    ut.user_id,
    ut.email,
    ut.password,
    ut.name,
    ut.birth_day,
    ut.gender,
    ut.provider,
    ut.phone_number,
    
    at.authority_id,
    at.user_id,
    at.role_id,
    
    rt.role_id,
    rt.role_name
  from
    user_tb ut
    left outer join authority_tb at on(at.user_id = ut.user_id)
    left outer join role_tb rt on(rt.role_id = at.role_id)
  where
    ut.email = #{email}
</select>

```

</br>

- id는 Repository에 있는 findUserByEmail이고, 그 반환 값은 User 객체다.
- where문에는 user 테이블에 있는 email과 findUserByEmail에 매개변수 email을 받아서 비교해준다.
- 이 where문에서 이메일 비교를 했을 때, email이 존재하다면 위 Service에서 에러 메세지를 띄우게 되는 것.

---

</br></br>

**Database**

![이메일 확인 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/a2e41380-3059-4807-a2b4-3c60148afe85)

</br>

- 영상에서 보여졌던 dmlgus3585@gmail.com이라는 이메일이 이미 존재하다는 것을 사진을 통해 확인할 수 있다.

---
  
</div>
</details>

<details>
<summary>그 외 유효성 검사 및 회원가입 성공 영상과 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![그 외 유효성 검사 및 회원가입 성공](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/2dac8417-6567-427f-855a-fe6c728a2fd1)

</br></br>

## FrontEnd

**회원가입 정보 입력**

```html

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
	    <Input id="input-with-icon-adornment"
		css={inputMargin}
		label="password"
		variant="outlined"
		placeholder="8-16자의 영문 및 숫자, 특수문자를 모두 포함"
		name="password"
		type="password"
		onChange={onChangeHandler} 
		startAdornment={
		    <InputAdornment position="start">
		    <Lock />
		    </InputAdornment>
		} />
	    {errorMessage.password && <Alert css={errorCss} severity="error">{errorMessage.password}</Alert>}
    </FormControl>
</div>

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
	    <Input id="input-with-icon-adornment" 
		label="password" 
		variant="outlined" 
		placeholder="비밀번호 재입력" 
		name="confirmPassword" 
		type="password" 
		onChange={onChangeHandler} 
		startAdornment={
		    <InputAdornment position="start">
		    <Lock />
		    </InputAdornment>
		} />
	     {errorMessage.confirmPassword && <Alert css={errorCss} severity="error">{errorMessage.confirmPassword}</Alert>}
    </FormControl>
</div>

```

</br>

- 비밀번호 입력하는 부분만 예시로 넣었다. 나머지는 형식이 똑같음.

---

</br></br>

**입력 받은 값 처리**

```javascript

const onChangeHandler = (e) => {
    const { name, value } = e.target;
    setSignUp({...signUp, [name]: value});
}

```

</br>

- 위 내용에서 name, value에는 이메일만 들어간 모습을 보여주었지만 여기서는 이메일 포함 모든 입력 값들이 들어가있다
- 입력 받은 값을 setSignUp에 데이터를 넣어준다.

---

</br></br>

**요청**

```html

<div css={signUpBtnContainer}>
    <Button variant="contained" css={signupBtn} onClick={signUpSubmit}>가입하기</Button>
</div>

```

</br>

```javascript

    const signUpSubmit = () => {
        register.mutate();
    }

```

</br>

```javascript

    const register = useMutation(async () => {
        
        if (!emailSubmitDisabled) {
            setEmailErrorMessage({email: ""})
            setErrorMessages({ email: "이메일 중복 확인을 해주시기 바랍니다." });
            return;
        }

        if (signUp.password !== signUp.confirmPassword) {
            setErrorMessages({confirmPassword: "비밀번호가 일치하지 않습니다."});
            return;
        }
        const data = {
            ...signUp, ...address
        }

        const option = {
            headers: {
                "Content-Type": "application/json"
            }
        }
        try {
            await axios.post("http://localhost:8080/auth/signup", JSON.stringify(data), option)
            setErrorMessages({email: "", password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "", zonecode: "", address: "", detailAddress: ""})
            alert("회원가입 완료")
            window.location.replace("/login")
        }catch(error) {
            setErrorMessages({email: "", password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "",zonecode: "", address: "", detailAddress: "", ...error.response.data.errorData})
        }
    });

```

</br>

- 이메일 중복확인 부분에서 setEmailSubmitDisabled에 true나 false를 줬다. 만약 false인 경우 이메일 중복확인을 하지 않고 가입하기를 눌렀을 때 서버에서 데이터를 처리하기 어려워 이렇게 처리를 해줬다. 비밀번호 재입력 부분도 마찬가지.

- 여기서 주소 검색을 해서 주소가 들어갈 경우, 이전에 들어갔던 유저 정보들 상태가 초기화되는 문제가 생겼었다.(이 때까진 signUp 상태에 주소 정보까지 다 넣었었음)
어떻게 해도 안 되길래 결국 상태를 둘로 나눠서 요청을 보낸 것.

- 에러가 있을 경우 errorMeesages에 유효성 검사를 하면서 줬던 메세지가 입력이 되고 저장이 된다. 그리고 에러 없이 요청이 간 부분에는 에러 메세지를 공백으로 비워준다.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class SignUpController {
	
	private final SignUpService signUpService;

	@ValidAspect
	@PostMapping("/signup")
	public ResponseEntity<?> signup(@Valid @RequestBody SignUpReqDto signUpReqDto, BindingResult bindingResult) {
		signUpService.signUp(signUpReqDto);
		return ResponseEntity.ok().body(true);
	}
	
}

```

</br>

- 요청에서 받은 데이터로 유효성 검사 실시 후 성공하면 signUpService에 signUp에 넘긴다.

---

</br></br>

**Dto**

```java

@Data
public class SignUpReqDto {
	@Email
	@NotBlank(message="이메일을 입력하세요")
	private String email;
	
	@Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,16}$",
		message = "비밀번호는 영문자, 숫자, 특수문자를 포함하여 8 ~ 16자로 작성")
	private String password;
	
	@Pattern(regexp = "^[가-힣]{2,7}$",
		message = "이름은 한글 이름만 작성 	가능합니다.")
	private String name;
	
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
            	message = "생년월일을 형식에 맞게 작성해주세요.")
	private String birthday;
    
	@Pattern(regexp = "^(male|female)$",
            	message = "성별을 체크해주세요.")
	private String gender;
    
    	@Pattern(regexp = "^[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}$",
    		message = "휴대전화번호 형식에 맞게 작성해주세요.")
    	private String phoneNumber;
    
	@NotBlank(message = "우편번호는 필수 입력 값입니다.")
	private String zonecode;
	
	@NotBlank(message = "주소는 필수 입력 값입니다.")
	private String address;
	
	private String buildingName;
	private String bname;
	
	@NotBlank(message = "상세 주소는 필수 입력 값입니다.")
	private String detailAddress;
	
	private String addressType;
	
	public User toUserEntity() {
		return User.builder()
				.email(email)
				.password(new BCryptPasswordEncoder().encode(password))
				.name(name)
				.birthday(birthday)
				.gender(gender)
				.phoneNumber(phoneNumber)
				.build();
	}
	
	public Address toAddressEntity() {
		return Address.builder()
				.zonecode(zonecode)
				.address(address)
				.buildingName(buildingName)
				.bname(bname)
				.detailAddress(detailAddress)
				.addressType(addressType)
				.build();
	}
}

```

</br>

- 유효성 검사 실패 시에 띄워지는 메세지들이다.
- 데이터가 잘 들어왔다면 toUserEntity와 toAddressEntity에 유저 정보들이 들어간다.
- 비밀번호는 보안성을 위해 BCrypt로 바꿔줬는데, 이 BCrypt는 Spring Security에서 제공하는 비밀번호 암호화기이기 때문에 사용을 하기 위해서는 Bean에 등록이 되어야 한다.

```java

@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}

```

- 이 코드는 웹 관련해 보안을 다루는 객체를 따로 만들었는데 그건 아래 jwt와 oauth2, 관리자 페이지에서 같이 다룰 것이다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class SignUpService {
	
	private final UserRepository signUpRepository;
	private User userEntity;

	public int signUp(SignUpReqDto signUpReqDto) {
		userEntity = signUpReqDto.toUserEntity();
		signUpRepository.signUpUser(userEntity);

		signUpRepository.saveAuthority(
				Authority.builder()
				.userId(userEntity.getUserId())
				.roleId(1)
				.build());
		
		Address addressEntity = signUpReqDto.toAddressEntity();
		addressEntity.setUserId(userEntity.getUserId());
		
		
		return signUpRepository.saveAddress(addressEntity);
	}
}

```

</br>

- 데이터베이스에 주소 테이블에는 userId가 있는데 회원가입을 하고, 데이터를 확인해보니 주소 테이블에 userId가 계속 0이었다. 그래서 출력으로 하나씩 추적해서 찾아봤더니 머릿속으로는 이해가 되질 않아 이 방법 저 방법 써보다가 User 객체를 전역 변수로 빼니까 됐다!

- Authority는 유저의 권한을 의미하는 객체이고, roleId는 1번이 ROLE_USER, 2번이 ROLE_ADMIN이다. 그래서 이건 일반 회원가입이기 때문에 ROLE_USER를 부여해준 것.

- 반환 자료형은 성공 건수로 실패 시 0, 성공 시 1이기 때문에 int로 잡아줌.

---

</br></br>

**Repository**

```java
@Mapper
public interface UserRepository {
	public int saveAddress(Address address);
	public int signUpUser(User user);
	public int saveAuthority(Authority authority);
}

```

- Service에서 주소 정보, 유저 정보, 권한 정보 받음.

---

**Sql**

- 주소 정보 넣기

```sql

<insert id="saveAddress" 
	parameterType="com.webproject.crowdfunding.entity.Address"
	useGeneratedKeys="true"
	keyProperty="addressId">

	insert into address_tb
	values
	(0, #{userId}, #{zonecode}, #{address}, #{buildingName}, #{bname}, #{detailAddress}, #{addressType})
</insert>

```

</br>

- 유저 정보 넣기

```sql

<insert id="signUpUser"
	parameterType="com.webproject.crowdfunding.entity.User"
	useGeneratedKeys="true"
	keyProperty="userId">

	insert into user_tb
	values
	(0, #{email}, #{password}, #{name}, #{birthday}, #{gender}, #{provider}, #{phoneNumber})
</insert>

```

</br>
  
- 권한 정보 넣기

```sql

<insert id="saveAuthority" parameterType="com.webproject.crowdfunding.entity.Authority">
	insert into authority_tb
	values
	(0, #{userId}, #{roleId})
</insert>

```

</br>

- 반환 자료형을 넣어주고, insert가 된 후에 자동생성된 키값을 해당 id에 맞게 넣어주고 있다.

---

</br></br>

**Database**

- 유저 정보 데이터

![회원가입 성공 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/351f5483-cfac-4fcd-aa3e-7d9884bce0a1)

</br>

- 주소 정보 데이터

![주소 정보 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/28027045-fda0-4313-932d-96bbbd5a33b8)

</br>

- 권한 정보 데이터

![권한 정보 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/0ced2a4d-b50b-4dd8-93fe-8439e8a89c1d)

</br>

- 이렇게 데이터를 확인할 수 있다.

---
  
</div>
</details>

<br/>

### **로그인 화면 구현 영상 및 코드 리뷰**

<details>
<summary>로그인 유효성 검사 및 예외 처리 영상 그 외 토큰 부여 및 권한 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![로그인 유효성 검사 및 예외처리](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/f095cb2f-d0a7-4127-9279-44e37efbe79a)

</br></br>

## FrontEnd

**웹에서 로그인 정보 입력**

```html

    <div css={loginRightSide}>
	<div css={loginInputContainer}>
	    <div css={loginInputContainerWrapId}>
		<i css={inputI}></i>
		<FormControl variant="standard">
		    <Input id="input-with-icon-adornment" 
			label="email" 
			variant="outlined" 
			placeholder="email" 
			name="email" 
			type="text" 
			onChange={informationHandle} 
			startAdornment={
			    <InputAdornment position="start">
			    <Mail />
			    </InputAdornment>
			} />
		    {errorMessages.email && <Alert css={errorCss} severity="error">{errorMessages.email}</Alert>}
		</FormControl>
	    </div>
	    <div css={loginInputContainerWrapPw}>
		<i css={inputI}></i>
		<FormControl variant="standard">
		    <Input id="input-with-icon-adornment" 
			label="password" 
			variant="outlined" 
			placeholder="password" 
			name="password" 
			type="Password" 
			onChange={informationHandle}
			onKeyPress={handleOnKeyPress}
			startAdornment={
			    <InputAdornment position="start">
			    <Lock />
			    </InputAdornment>
			} />
		    {errorMessages.password && <Alert css={errorCss} severity="error">{errorMessages.password}</Alert>}
		</FormControl>
	    </div>
	</div>
	<div>
	    <button css={loginBtn} onClick={loginHandleSubmit}>로그인</button>
	</div>

```

</br>

- 아이디와 비밀번호를 입력한 후 로그인 버튼을 클릭하고, 오류가 있을 시에 에러 메세지를 띄우게 설계

---

</br></br>

**입력 받은 값 처리**

```javascript

    const informationHandle = (e) => {
        const { name, value } = e.target;
        setLoginUser({...loginUser, [name]: value})
    }

```

</br>

- 위에서 다뤘던 내용과 동일

---

</br></br>

**요청**

```javascript

    const login = useMutation(async() => {
        const option = {
            headers: {
                "Content-Type": "application/json"
            }   
        }
        try{
            const response = await axios.post("http://localhost:8080/auth/login", JSON.stringify(loginUser), option);
            setErrorMessages({email: "", password: ""});
            const accessToken = response.data.accessToken;
            localStorage.setItem("accessToken", accessToken); 
            setAuthenticated(true);
            window.location.replace("/");
        } catch(error) {
            setErrorMessages({email: "", password: "", ...error.response.data.errorData});
            if(error.response.data.message === "로그인 실패") {
                alert("사용자 정보를 확인해주세요.")
            }
        }
    })

    const loginHandleSubmit = () => {
        login.mutate();
    }

```

</br>

- 데이터가 성공적으로 들어갔으면 웹페이지를 이용할 수 있는 토큰을 부여한다.

- useRecoilState는 상태를 전역으로 관리를 하는 것.

</br>

```javascript

const [ authenticated, setAuthenticated ] = useRecoilState(authenticatedState);

```

</br>

```javascript


export const authenticatedState = atom({
    key: "authenticatedState",
    default: false
});

```

</br>

- 기본 값은 false이고, 상태 하나하나를 atom으로 보는 것인데 여기서 atom이란 하나의 상태를 나타내는 객체로 생각하면 된다.

- 데이터가 성공적으로 들어갔으면 기본 값이 false였던 것을 로그인 코드에서 true로 바꿔주는 것이다.

- 이 코드를 만든 이유는 로그인을 한 사람과 하지 않은 사람에게 다른 이용을 할 수 있도록 하기 위해 만들었다.

---

</br></br>

**권한이 필요한 웹페이지에 권한 부여**

```javascript

export const refreshState = atom({
    key: "refreshState",
    default: true
});

```

</br>

```javascript

const AuthRoute = ({ path, element }) => {
    const [ refresh, setRefresh ] = useRecoilState(refreshState);
    const accessToken = localStorage.getItem("accessToken");
    const navigate = useNavigate();

    const authenticated = useQuery(["authenticated"], async () => {
     const option = {
        headers: {
            Authorization: `Bearer ${accessToken}`
        }
     }
        try {
            const response = await axios.get("http://localhost:8080/auth/authenticated", option);
            return response;
        } catch(error) {
            localStorage.removeItem("accessToken");
            navigate("/login");
        }
    }, {
        refetchInterval: 1000 * 60
    });

    const principal = useQuery(["principal"], async () => {
        const option = {
            headers: {
                Authorization : `Bearer ${accessToken}`
            }
         }

        const response = await axios.get("http://localhost:8080/principal", option)
        return response;
        },{
            onSuccess: (response) => {
                const roles = response.data.authorities.split(",");
                if (path !== "/" && path.startsWith("/admin") && !roles.includes("ROLE_ADMIN")) {
                    alert("접근 권한이 없습니다.");
                    navigate("/");
                }
            },
            enabled: !!accessToken && !!authenticated.data
    });

    useEffect(() => {
        if(!refresh) {
            setRefresh(true);
        }
    }, [refresh]);
    
    

    if(authenticated.isLoading) {
        return <div>로딩중...</div>;
    }

    const permitAll = ["/login", "/signup", "/auth/oauth2/login", "/auth/oauth2/signup", "/auth/oauth2/merge"];

    if(!authenticated.data.data) {
        if(permitAll.includes(path)){
            return element;
        }
    }

    if(permitAll.includes(path)){
        navigate("/");
    }

    return element;
};

```

</br>

- useEffect를 사용함으로써 렌더링이 될 때 refresh가 false이면 true로 주면서, 강제로 작업을 수행할 수 있게 만들었다.

- 렌더링이 될 때 마다 로그인을 하면서 발급 받은 토큰를 1분(refetchInterval: 1000 * 60에서 1000은 1초를 의미한다) 마다 인증을 하는데, 토큰이 만료가 되거나 잘못된 형식 등 예외가 터지면 토큰을 제거하고 로그아웃을 시킨다.

- 렌더링이 될 때 마다 인증이 된 토큰을 보내는데, 이 토큰에는 유저의 정보들이 담겨 있다. 이 정보 속을 열어보면 부여해준 권한이 ROLE_ADMIN이 아닌데 웹 주소창에 /admin이라는 페이지를 강제로 열어서 접근을 했을 때 권한이 없다는 것을 알려준다.

- authenticated에서 인증되지 않은 사용자에 대해 permitAll에 있는 경로를 이용할 수 있게 하고, 인증된 사용자들은 저 경로를 이용할 수 없도록 메인 화면으로 보낸다.
이렇게 만들어준 이유는 인증이 됐다는 것은 로그인이 된 것을 의미하는데, 로그인이 된 사람이 다시 로그인 창을 들어가는 상황이나 회원가입을 하는 상황 등 옳지 않은 상황들을 생각하여 넣어줬다.

</br>

```javascript

function App() {
  return (
    <>
      <Global styles={Reset}></Global>
      <HeaderMain />
      <Routes>
        <Route path="/" element={<Main />} />
        <Route path="/login" element={<AuthRoute path="/login" element={<Login />} />} />
        <Route path="/signup" element={<AuthRoute path="/signup" element={<SignUp />}/>} />
        <Route path="/search" element={<Search />} />
        <Route path="/giving" element={<Giving />} />
        <Route path="/giving/:pageId" element={<GivingDetail />} />
        <Route path="/funding" element={<Funding />} />
        <Route path="/funding/:pageId" element={<FundingDetail />} />
        <Route path="/admin/register/page" element={<AuthRoute path="/admin/register/page" element={<RegisterPage />}/>} />
        <Route path='/auth/oauth2/login' element={<AuthRoute path={"/auth/oauth2/login"} element={<OAuth2Login />}/>} />
        <Route path='/auth/oauth2/signup' element={<AuthRoute path={"/auth/oauth2/signup"} element={<OAuth2SignUp />}/>} />
        <Route path='/auth/oauth2/merge' element={<AuthRoute path={"/auth/oauth2/merge"} element={<OAuth2Merge />}/>} />
      </Routes>
    </>
  );
}

```

</br>

- 경로 관련 app.js 코드다.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class LoginController {
	
	private final LoginService loginService;
	
	@ValidAspect
	@PostMapping("/login")
	public ResponseEntity<?> login(@Valid @RequestBody LoginReqDto loginReqDto, BindingResult bindingResult) {
		return ResponseEntity.ok(loginService.login(loginReqDto));
	}
	 
	@GetMapping("/authenticated")
	public ResponseEntity<?> authenticated(@RequestHeader(value = "Authorization") String accessToken) {
		return ResponseEntity.ok().body(loginService.authenticated(accessToken));
	}
}

```

- 값을 ok 안에 넣거나, body 안에 넣거나 똑같다. 하지만 badRequest는 안 됨. ok만 가능

---

</br></br>

**Dto**

```java

@Data
public class LoginReqDto {
	@Email(message = "존재하지 않는 이메일입니다.")
	@NotBlank(message="이메일을 입력하세요")
	private String email;
	
	@Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,16}$",
			message = "비밀번호는 영문자, 숫자, 특수문자를 포함하여 8 ~ 16자로 작성")
	private String password;
}

```

</br>

- 로그인 유효성 검사

---

**Service**

```java

@Service
@RequiredArgsConstructor
public class LoginService {

	private final AuthenticationManagerBuilder authenticationManagerBuilder;
	private final JwtTokenProvider jwtTokenProvider;
	private final PasswordEncoder passwordEncoder;
	private final UserRepository userRepository;
	
	public JwtRespDto login(LoginReqDto loginReqDto) {
		
		User userEntity = userRepository.findUserByEmail(loginReqDto.getEmail());
		
		if(userEntity == null || !passwordEncoder.matches(loginReqDto.getPassword(), userEntity.getPassword())) {
			throw new CustomException("로그인 실패", ErrorMap.builder().put("login", "사용자 정보를 확인하세요").build());
		}
		
		UsernamePasswordAuthenticationToken authenticationToken = 
				new UsernamePasswordAuthenticationToken(loginReqDto.getEmail(), loginReqDto.getPassword());
		Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
		return jwtTokenProvider.generateToken(authentication);
	}
	
	public boolean authenticated(String accessToken) {
		return jwtTokenProvider.validateToken(jwtTokenProvider.getToken(accessToken));
	}
}

```

- 먼저, 데이터베이스에서 저장되어있는 이메일을 들고와서 현재 로그인 하려는 이메일과 비교를 했을 때 일치하지 않거나, 정보가 없으면 에러메세지를 띄우게 했다. 

- 그 다음 UsernamePasswordAuthenticationToken을 선언해주면서 로그인한 아이디와 비밀번호를 가지고 인증 토큰을 하나 만든다.

- 그 토큰을 가지고 authenticationManagerBuilder.getObject().authenticate(authenticationToken)에다 넣어주는데 여기서부터 스프링부트 내에서 authenticationManagerBuilder가 이 토큰 정보를 가지고 loadByUsername라는 함수를 실행시킨다.

```java

@Service
@RequiredArgsConstructor
public class PrincipalDetailsService implements UserDetailsService {

	private final UserRepository signUpRepository;

	@Override
	public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
		User userEntity = signUpRepository.findUserByEmail(email);
		return userEntity.toPrincipal();
	}

}

```

</br>

- 위를 실행시킨다는 의미인데, 여기는 로그인 정보를 담고 있는 부분이다.

- 반환하고 있는 toPrincipal을 보자면 아래와 같이 되어있다.

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
	private int userId;
	private String email;
	private String password;
	private String name;
	private String birthday;
	private String gender;
	private String provider;
	private int addressId;
	private String phoneNumber;
	private List<Authority> authorities;
	
	public PrincipalUserDetails toPrincipal() {
		return PrincipalUserDetails.builder()
				.userId(userId)
				.email(email)
				.password(password)
				.roles(authorities)
				.build();
	}
}

```

</br>

```java

@Getter
@Builder
public class PrincipalUserDetails implements UserDetails{

	private static final long serialVersionUID = -8654755481982862798L;
	
	private int userId;
	private String email;
	private String password;
	private List<Authority> roles;
	
	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		List<SimpleGrantedAuthority> authorities = new ArrayList<>();
		roles.forEach(role -> {
			authorities.add(new SimpleGrantedAuthority(role.getRole().getRoleName()));
		});
		return authorities;
	}

	@Override
	public String getPassword() {
		return password;
	}

	@Override
	public String getUsername() {
		return email;
	}

	// 사용기간 만료 = false
	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	// 계정을 잠궈버림 = false
	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	// 비밀번호 5회 틀렸을 때 잠궈버림 = false
	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	// 계정 비활성 상태(이메일 인증을 완료해야 하거나 또는 전화번호 인증을 하지 않았을 때) = false
	@Override
	public boolean isEnabled() {
		return true;
	}

}

```

</br>

- 권한 객체를 생성해준다.

- 권한 목록을 반환, List가 Collection으로 업캐스팅됨

- User 객체에서 Builder를 이용해 값들을 넣어준 다음, 권한 객체까지 만들어주면 이제 Service에서 Authentication이라는 객체가 생성이 된다.

</br>

위 코드를 보면 생성된 Authentication 객체를 jwtTokenProvider.generateToken에 넣어주는데, 이제 jwtTokenProvider로 가보자.

```java

@Component
public class JwtTokenProvider {
	@Autowired
	private UserRepository userRepository;
	private final Key key;

	public JwtTokenProvider(@Value("${jwt.secret}") String secretKey) {	// @Component일 때 사용 가능. yml의 key값이 매개변수로 들어간다
		key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
	}

	public JwtRespDto generateToken(Authentication authentication) {
		StringBuilder builder = new StringBuilder();
		authentication.getAuthorities().forEach(authority -> {
			builder.append(authority.getAuthority() + ",");		// 문자열 사용가능, role이 하나씩 나온다.

		});

		builder.delete(builder.length() - 1, builder.length());		// ~부터 ~까지 지워라. 쉼표를 지우기 위해 씀

		String authorities = builder.toString();	// role 권한들을 문자열로 바꾸기 위해서

		Date tokenExpiresDate = new Date(new Date().getTime() + (1000 * 60 * 60));	// 1000 * 60을 하면 1분이다. 그래서 1시간을 만료 시간으로 설정

		String accessToken = Jwts.builder()
				.setSubject(authentication.getName())	// 토큰의 제목(큰이름), getName() = email
				.claim("auth", authorities)	// 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터들로 모두 선택적으로 작성이 가능함
				.setExpiration(tokenExpiresDate)	// 토큰의 만료기간
				.signWith(key, SignatureAlgorithm.HS256)	// 토큰 암호화
				.compact();

		return JwtRespDto.builder().grantType("Bearer").accessToken(accessToken).build();	// 이후 controller가 받는다.

	}

	// Bearer를 뗀 토큰 값을 풀어서 검사함.
	public boolean validateToken(String token) {
		try {
			Jwts.parserBuilder()	// Jwt 형태를 Json이 아닌 java 형태로 쓰겠다
			.setSigningKey(key)		// token이 만들어진 key로 되어있는지 확인
			.build()
			.parseClaimsJws(token);		// 유효성 검사

			return true;

		// Security 라이브러리에 오류가 있거나, JSON의 format이 잘못된 형식의 JWT가 들어왔을 때 예외
		}catch (SecurityException | MalformedJwtException e) {
		}catch (ExpiredJwtException e) {
		}catch(UnsupportedJwtException e) {
		}catch(IllegalArgumentException e) {
		}catch(Exception e) {

		}

		// 예외가 일어나면 인증되지 않았다, 쓸 수 없는 토큰이다
		return false;
	}
	// 요청할 때 토큰을 Bearer ~~~~~~~~~~라는 값으로 보내는데, 토큰값만 넘겨주기 위해 앞에 Bearer를 잘라주는 과정.
	// 토큰 앞에 Bearer를 붙인 이유는 개발자끼리의 약속이라고 한다.
	public String getToken(String token) {
		String type = "Bearer ";
		if(StringUtils.hasText(token) && token.startsWith(type)) {
			return token.substring(type.length());
			
		}
		return null;
		
	}
	public Claims getClaims(String token) {
		return Jwts.parserBuilder()
				.setSigningKey(key)
				.build()
				.parseClaimsJws(token)
				.getBody();
	}
	
	public Authentication getAuthentication(String accessToken) {
		Authentication authentication = null;
		
		Claims claims = getClaims(accessToken);		// Claims 통째로 들고오기

		// Spring에서 기본적으로 지원해주는 UserDedatils임
		// new User(username, password, 권한) == PrincipalDetails
		// password는 공개되면 안 되기 때문에 공백이다
		User user = userRepository.findUserByEmail(claims.getSubject());
		PrincipalUserDetails principalUserDetails = user.toPrincipal();
		
		// new UsernamePasswordAuthenticationToken(User객체, 자격 증명 객체(SSL 등 회사든 공공에서든 인증서가 필요할 때. https에서 증명할 때 쓰임), 권한)
		// return하면 업캐스팅이 돼서 Authentication 객체가 된다. UsernamePasswordAuthenticationToken를 타고 들어가면 Authentication을 implement 하고 있다.
		// 임시의 Authentication 객체가 생성
		authentication = new UsernamePasswordAuthenticationToken(principalUserDetails, null, principalUserDetails.getAuthorities());
		return authentication;
	}
}

```

</br>

- 여기에다가 정리하려니 복잡해서 한 줄 주석으로 정리를 했다. 이제 토큰이 잘 가공이 되면 JwtRespDto라는 객체가 반환이 되는데 코드는 아래와 같다.

```java

@Builder
@Data
public class JwtRespDto {
	private String grantType;
	private String accessToken;

}

```

</br>

- 이제 로그인할 때 필요한 인증을 거치고, 인증의 표시인 토큰까지 발급을 받게 되면 웹페이지에서 권한이 들어간 서비스를 사용할 수 있게 된다.

이제 종합적으로 보면

1. Service에서 아이디와 비밀번호를 가지고 인증에 필요한 토큰을 하나 만든다.
2. 그 토큰으로 데이터베이스에 있는 유저가 맞는지 이메일로 확인을 한다.
3. 이메일 확인이 되면 userId, 이메일, 비밀번호, 권한 내용까지 반환을 한다.
4. Authentication이라는 객체가 생성이 되면서 유저가 인증이 된 것이다.
5. 생성된 Authentication 객체의 정보를 jwtTokenProvider.generateToken에 넘기는데 여기서 토큰을 가공을 해준다.
6. 이상없이 가공이 끝나면 가공된 토큰을 Controller로 반환을 해주고 웹에서 받는다.

---
  
</div>
</details>

<br />

### **펀딩 메인 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>1. 카테고리 적용 영상</summary>
<div markdown="1">
  
![카테고리 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/402755b6-cfc9-4570-8a93-0c4274a2d2e8)

  
</div>
</details>

<details>
<summary>2. 정렬(전체, 진행중, 종료) 영상</summary>
<div markdown="1">

![정렬(전체, 진행중, 종료)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/8b3de60f-18f2-4500-bc2b-12b6f255214b)
  
</div>
</details>

<details>
<summary>3. 정렬(최신 순, 참여 금액 순, 참여율 순, 종료 임박 순) 영상</summary>
<div markdown="1">
<br/>

- 최신 순
  
![최신 순 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/6ee7a5ac-fa0e-491a-ab49-4d046c3c7a93)

<br/><br/>

- 참여금액 순
  
![참여 금액 순 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/2c598491-a31d-4f0b-887e-b296e686cd10)

<br/><br/>

- 참여율 순

![참여율 순 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/8034d691-c756-449c-b0fe-bd40a648a002)

<br/><br/>

- 종료 임박 순

![종료 임박 순 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/edbb6514-334a-4ae8-a8a5-dff336992268)
  
</div>
</details>

<details>
<summary>카테고리 관련 코드 리뷰</summary>
<div markdown="1">

## FrontEnd

**요청**

- 메인 페이지에 쓸 것

```javascript
    const [ searchParam, setSearchParam ] = useState({page: 1, fundingSortingReward: "최신 순", fundingSortingStatus: "전체"});
    const [ refresh, setRefresh ] = useState(true);

    const fundingData = useQuery(["fundingData"], async () => {
        const option = {
            params : {
                ...searchParam
            }
        }
        const response = await axios.get("http://localhost:8080/funding/main", option);
        return response;
    }, {
        enabled: refresh,
        onSuccess: () => {
            setRefresh(false);
        }
    });

```

</br>

- 카테고리에 쓸 것

```javascript

    const fundingCategorys = useQuery(["fundingCategory"], async () => { 
        return await axios.get("http://localhost:8080/funding/category");
    });

```

</br>

- post요청을 보낼 땐 useMutation을 썼는데 여기서는 useQuery를 쓰는 모습을 볼 수 있다. 먼저, useMutation은 post, put, delete와 같은 요청을 처리하는 데에 있어서 쓸 수 있고, useQuery는 데이터를 조회할 때 사용하기 때문에 get 요청에 쓰인다. useQuery도 마찬가지로 상태관리나 에러 처리에 있어서 용이하기에 사용을 한다.

- searchParam은 페이지네이션과 정렬을 가공하기 위해 요청 데이터로 보냈다.

- enabled는 요청을 활성화할 것인지 비활성화를 할 것인지 결정을 한다. 초기값에 true를 넣어줌으로써 처음 요청을 보내는데 활성화를 시키고, 요청이 오고나면 onSuccess가 작동을 해 다시 refresh를 false로 주면서 enabled를 비활성화 시키는 모습을 볼 수 있다. 이는 데이터를 처음 한 번만 가져오면서 에러를 최소화를 시킬 수 있고, 로딩 시간도 짧게 할 수 있기 때문에 사용을 했다.

---

</br></br>

**펀딩 메인 페이지 html 코드**

```html

<div>
    <div css={welcomeFunding}><FundingSlide /></div>
    <div css={fundingMain}>
	<div css={fundingHeader}>
	    <button css={fundingCategoryMainButton} onClick={() => handleCategoryClick(null)}>전체</button>
	    {fundingCategorys.isLoading ? <div>...불러오는 중</div> : fundingCategorys.data.data.map(fundingCategory => (
		<div css={fundingCategoryContainer}>
		    <button css={fundingCategoryButton}
			    onClick={() =>handleCategoryClick(fundingCategory.fundingCategoryId)}
			    key={fundingCategory.fundingCategoryId}>
			{fundingCategory.categoryName}
		    </button>
		</div>
	    ))}
	</div>
	    <div css={sortingFundingStatusContainer}>
		<div css={fundingStatusDetail} onClick={statussortingHidden}>
		    <button css={fundingStatus}>{sortingStatus}</button>
		    <div>{statusHiddenFlag ? "△" : "▽"}</div>
		    {statusHiddenFlag ? (<ul css={sortingFundingStatusList}>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>전체</li>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>진행중</li>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>종료</li>
		    </ul>) : ""}
		</div>
		<div css={fundingStatusDetail} onClick={rewardsortingHidden}>
		    <button css={fundingStatus}>{sortingReward}</button>
		    <div>{rewardHiddenFlag ? "△" : "▽"}</div>
		{rewardHiddenFlag ? (<ul css={sortingFundingRewardStatusList}>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>최신 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>참여 금액 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>참여율 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>종료 임박 순</li>
		</ul>) : ""}
		</div>
	    </div>
	<div css={fundingMainConatiner}>
	    {fundingData.data.data.fundingList.filter(
	    funding => selectedCategoryId === null ||
	    funding.fundingCategoryId === selectedCategoryId).map(funding => (
		<div css={fundingContainer} onClick={() => {fundingDetailHandle(funding.pageId)}}>
		    <div>
			<div css={imgBox}>
			    <img css={img} src={`http://localhost:8080/image/main/${funding.mainImgUrl}`} />
				<div css={checkFunding({funding})}>
				    <div css={fundingTxt}>펀딩</div>
				    <div>{funding.joinPercent >= 100 ? "성공" : "종료"}</div>
				</div>
			</div>
		    </div>
			<div key={funding.pageId}>
			    <div css={fundingContainerMainTitlePrice}>
				<div css={fundingContainerMainTitlePageTitle}>{funding.pageTitle}</div>
				<div css={fundingContainerMainPricePadding}>
				    <div css={fundingContainerMainPrice}>{funding.joinPercent}%</div>
				</div>
			    </div>
			    <div css={fundingContainerMainUsername}>{funding.fundingSummaryName}</div>
			</div>
		    <div css={fundingContainerFooter}>
			    <div css={fundingContainerFooterEventStatus}>{funding.eventStatus}</div>
			    <div css={fundingContainerFooterPrice}>{new Intl.NumberFormat('en-US').format(funding.totalRewardPrice)}원</div>
		    </div>
		</div>
	    ))}
	</div>
	<div>
	    <div css={pageNationContainer}>
		<div css={pageNationIndex} onClick={loadMore}>더보기</div>
	    </div>
	</div>
	    <div css={footerContainer}>
		<Footer />
	    </div>
    </div>
</div>

```

</br>

- 카테고리에 전체만 따로 빼놓은 이유는 현재 데이터베이스에는 전체라는 카테고리가 존재하지 않아 따로 처리해주었다. onClick 속성 안에 handleCategoryClick은 categoryId를 넘겨준다.

- 정렬 방식에서 열림과 닫힘을 넣기 위해 클릭 시에 작동하는 true false 상태를 주었다.

- 펀딩 기간이 종료가 됐을 때 펀딩 금액이 목표 금액에 100퍼센트 미만일 경우에 종료, 이상일 경우에 성공을 줌으로써 유저들이 종료된 펀딩 상품들의 가치를 쉽게 파악할 수 있다.

- 나머지는 데이터베이스에서 들고온 데이터들을 그대로 넣어준 것.

---

</br></br>

**응답 받은 데이터 가공**

```javascript

    const handleCategoryClick = (categoryId) => {
        setSelectedCategoryId(categoryId);
    };

    const statussortingHidden = () => {
        if(statusHiddenFlag) {
            setStatusHiddenFlag(false);
        }else {
            setStatusHiddenFlag(true);
        }
    }

    const rewardsortingHidden = () => {
        if(rewardHiddenFlag) {
            setRewardHiddenFlag(false);
        }else {
            setRewardHiddenFlag(true);
        }
    }

    const sortingStatusHandle = (e) => {
        const statusText = e.target.textContent;
        setSearchParam({...searchParam, fundingSortingStatus: statusText, page: 1})
        setSortingStatus(statusText);
        setStatusHiddenFlag(false);
        setRefresh(true);
    }

    const sortingRewardHandle = (e) => {
        const rewardText = e.target.textContent;
        setSearchParam({ ...searchParam, fundingSortingReward: rewardText, page: 1});
        setSortingReward(rewardText);
        setRewardHiddenFlag(false);
        setRefresh(true);
    };

    const fundingDetailHandle = (pageId) => {
        navigate("/funding/" + pageId);
    }

    const loadMore = () => {
        if(!refresh) {
            setSearchParam({ ...searchParam, page: searchParam.page + 1});
            setRefresh(true);
        }
    };

```

</br>

- 카테고리 선택에 보면 html에서 카테고리 버튼을 누르면 해당 카테고리 id가 들어가는데 그러면 그 id에 해당하는 목록들만 보여진다. 초기 값은 null인데 아무것도 누르지 않은 null인 상태면 전부 다 보여지는 전체 카테고리도 만들었다.

- 정렬 버튼 열고 닫기

- 정렬의 상태가 바뀌면 바뀐 값을 넣어주면서 상태를 업데이트함.

- 보고 싶은 펀딩의 상세 내용이 궁금해 클릭을 하면 펀딩 상세페이지로 이동을 한다.

- 더보기를 누를 때 마다 index가 0부터 1씩 증가하는데 자세한 페이지네이션 기능은 아래 코드 리뷰에서 진행할 것이다. 

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/funding")
public class FundingMainController {
 
	private final FundingService fundingService;
	
	@GetMapping("/main")
	public ResponseEntity<?> fundingData(FundingEventReqDto fundingMainReqDto) {
		System.out.println(fundingMainReqDto);
		return ResponseEntity.ok(fundingService.toSaveFunding(fundingMainReqDto));
	}
	
	@GetMapping("/category")
	public ResponseEntity<?> fundingCategory() {
		return ResponseEntity.ok(fundingService.fundingCategory());
	}
	
}

```

- 위에서 보낸 요청 데이터를 받고 Service로 넘긴다.

---

</br></br>

**Dto**

```java

@Data
public class FundingEventReqDto {
	private int page;
	private String fundingSortingReward;
	private String fundingSortingStatus;
}

```

- 요청에서 보낸 것처럼 기본 값으로 page: 1, fundingSortingReward: 최신 순, fundingSortingStatus: 전체가가 들어간다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class FundingService {
	private final FundingRepository fundingRepository;
	
	public Map<String, Object> toSaveFunding(FundingEventReqDto fundingEventReqDto) {
		List<FundingMainRespDto> fundingList = new ArrayList<>();

		int index = fundingEventReqDto.getPage() * 20;
		Map<String, Object> eventStatusMap = new HashMap<>();
		eventStatusMap.put("index", index);
		eventStatusMap.put("fundingSortingReward", fundingEventReqDto.getFundingSortingReward());
		eventStatusMap.put("fundingSortingStatus", fundingEventReqDto.getFundingSortingStatus());
		
		fundingRepository.saveFunding(eventStatusMap).forEach(funding -> {
			fundingList.add(funding.toSaveFunding());
		});
		
		int totalCount = fundingRepository.getTotalCount(eventStatusMap);
		
		Map<String, Object> responseMap = new HashMap<>();
		responseMap.put("totalCount", totalCount);
		responseMap.put("fundingList", fundingList);
		return responseMap;
	}
	
	public List<FundingCategoryRespDto> fundingCategory() {
		List<FundingCategoryRespDto> fundingCategorys = new ArrayList<>();
		
		fundingRepository.getFundingCategory().forEach(fundingCategory -> {
			fundingCategorys.add(fundingCategory.fundingCategoryToDto());
		});
		return fundingCategorys;
	}
	
	
}

```

- FundingMainRespDto, FundingCategoryRespDto에는 펀딩 메인페이지에 필요한 sql에서 가공한 데이터가 들어간다. 많은 데이터가 담겨있기 때문에 List로 담았다.

- page는 더보기를 클릭할수록 20개씩 보여지기 위해 page가 1부터 증가할 때 마 20을 곱하도록 했다.

- Map을 써준 이유는 프론트에서 데이터를 파악하기 쉽게 value에 걸맞은 key 값을 설정을 해주고 있다.

- 나머지도 sql에서 가공한 데이터를 들고온다.

- 뒤에서도 이런 형식의 코드를 주로 사용할 것이다.

---

</br></br>

**ResponseDto**

- 펀딩 메인

```java

@Builder
@Data
public class FundingMainRespDto {
	private int pageId;
	private String fundingSummaryName;
	private String pageTitle;
	private String username;
	private int recentSort;
	private String nearDeadlineSort;
	private String eventStatus;
	private int goalTotal;
	private int totalRewardPrice;
	private int joinPercent;
	private String mainImgUrl;
	private int fundingCategoryId;
}

```



**Repository**

```java

@Mapper
public interface FundingRepository {
	public List<FundingCategory> getFundingCategory();
	public List<Funding> saveFunding(Map<String, Object> eventStatusMap);
	public int getTotalCount(Map<String, Object> totalMap);
}

```

---
  
</div>
</details>

<br/>

### **펀딩 상세 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>현재 진행 중인 펀딩</summary>
<div markdown="1">

![상세페이지 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/03dbfdd9-aa06-49b6-ae18-cbc3eb8a917a)

</div>
</details>

<details>
<summary>펀딩 참여하기(결제)</summary>
<div markdown="1">

![결제 처음 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/efa13972-cf36-46ce-8d24-88ef1951057a)

<br/><br/>

![KakaoTalk_20230624_165355960_01](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/3fab79c9-46f7-4985-8761-4cdb7d354bed)

<br/><br/>

![KakaoTalk_20230624_165355960_02](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/bf156ff1-3fbe-4c58-aba3-f42d68983b0c)

<br/><br/>

![KakaoTalk_20230624_165355960_03](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/d8413386-8d92-42d4-a32c-69af3ceb6727)

<br/><br/>

</div>
</details>

<details>
<summary>종료된 펀딩</summary>
<div markdown="1">

![종료된 펀딩](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/238f395c-98bc-4262-99c6-e3ce59013b34)

</div>
</details>

<br/>

### **관리자 펀딩 및 기부 등록 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 및 펀딩 등록 유효성 검사</summary>
<div markdown="1">

![관리자 페이지 유효성 검사 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/d5d256ce-e970-40a9-9496-9aa57a43197f)

</div>
</details>

<details>
<summary>기부 등록</summary>
<div markdown="1">

![기부 등록 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/311a9a48-11e9-44a9-8691-0def0355ba07)

</div>
</details>

<details>
<summary>펀딩 등록</summary>
<div markdown="1">

![펀딩 등록 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/69890336-542c-42f2-b6fd-43ee0dbd6f89)

</div>
</details>

<br/>

### **관리자 펀딩 및 기부 수정 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 수정</summary>
<div markdown="1">

![기부 수정 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/65ce4d46-6748-4936-bcba-4bd0ca3d5a26)

</div>
</details>

<details>
<summary>펀딩 수정</summary>
<div markdown="1">
  
![펀딩 수정 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/5c1ae2c5-038e-49be-8fbc-611f014ca421)

</div>
</details>

<br/>

### **관리자 펀딩 및 기부 삭제 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 삭제</summary>
<div markdown="1">
  
![기부 삭제 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/91f9ff1a-73c5-4350-9682-3bfb66b8552d)

</div>
</details>

<details>
<summary>펀딩 삭제</summary>
<div markdown="1">
  
![펀딩 삭제 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/b0d12753-abce-45a6-9fa3-caca513d43f4)

</div>
</details>

<br/>

### **OAuth2 회원가입 및 로그인 화면 구현 영상 및 코드 리뷰**

<details>
<summary>OAuth2 회원가입 및 로그인</summary>
<div markdown="1">
  
![OAuth2 회원가입 및 로그인 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/c2bebc58-65d9-4b68-adba-dc939e1d0883)

</div>
</details>

<br/>

### **OAuth2 Google, Kakao 계정 통합 화면 구현 영상 및 코드 리뷰**

<details>
<summary>OAuth2 계정 통합</summary>
<div markdown="1">
  
![OAuth2 계정 통합 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/478e6782-37a1-4e0b-b352-fcbd70c0b817)


</div>
</details>

<br/>
