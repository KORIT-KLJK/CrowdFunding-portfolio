## **📗 목차**


🏆 [프로젝트 소개](#-프로젝트-소개)

👨🏻‍💻 [팀원 소개](#-팀원-소개)

🛠 [개발 도구](#-개발-도구)

⏰ [프로젝트 일정](#-프로젝트-일정)

🔗 [API명세서와 ERD설계도](#-API명세서와-ERD설계도)
  
📝 [메뉴구조도](#-메뉴구조도)
  
✨ [화면 구현 및 코드 리뷰](#-화면-구현-및-코드-리뷰)
  - [회원가입 화면 구현 영상 및 코드 리뷰](#회원가입-화면-구현-영상-및-코드-리뷰)
  - [로그인 화면 구현 영상 및 코드 리뷰](#로그인-화면-구현-영상-및-코드-리뷰)
  - [펀딩 메인 페이지 화면 구현 영상 및 코드 리뷰](#펀딩-메인-페이지-화면-구현-영상-및-코드-리뷰)
  - [펀딩 상세 페이지 화면 구현 영상 및 코드 리뷰](#펀딩-상세-페이지-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 등록 페이지 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-등록-페이지-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 수정 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-수정-화면-구현-영상-및-코드-리뷰)
  - [관리자 펀딩 및 기부 삭제 화면 구현 영상 및 코드 리뷰](#관리자-펀딩-및-기부-삭제-화면-구현-영상-및-코드-리뷰)
  - [OAuth2 회원가입 및 로그인 화면 구현 영상 및 코드 리뷰](#OAuth2-회원가입-및-로그인-화면-구현-영상-및-코드-리뷰)
  - [OAuth2 Google, Kakao 계정 통합 화면 구현 영상 및 코드 리뷰](#OAuth2-Google-Kakao-계정-통합-화면-구현-영상-및-코드-리뷰)
  
👨🏻‍💻 [느낀점](#-느낀점)

<br/>

## **🏆 프로젝트 소개**

- 프로젝트 제목 - 펀딩 및 기부 서비스 테스트

- 프로젝트 목적 - 배운 것들을 복습 및 활용, 협업에 대한 이해

- 분류 - 팀프로젝트

- 제작 기간 - 2023.05.03 ~ 2023.06.07

<br/>

## **👨🏻‍💻 팀원 소개**

<br/>

> **팀장: 정의현** 
- 사용한 통계에 프로젝트 설계
- 펀딩페이지 CRUD 기능 구현 및 CSS
- 로그인 및 회원가입 기능 구현
- security jwt 및 accessToken 디테일 작업
- 파일 입출력
- API 명세서
- 관리자 CRUD 기능 구현
- OAuth2 로그인, 회원가입 기능 구현
- 결제 기능 구현

<br/>

> **팀원: 김수현** 
- 메인 페이지 기능 구현 및 CSS
- header 작업
- ppt 작업

<br/>

> **팀원: 김상현** 
- 기부페이지 CRUD 기능구현 및 CSS
- 로그인 회원가입 페이지 CSS
- ERD 명세서
- security jwt 및 accessToken 틀 작업

<br/>

> **팀원: 이해강** 
- 데이터 크롤링
- 검색 기능

<br/>

## **🛠 개발 도구**

<br/>

### FrontEnd

<img src="https://img.shields.io/badge/Visual Studio Code-007ACC?style=for-the-badge&logo=Visual Studio Code&logoColor=white"/> <img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> 
<img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white"> 
<img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> 
<img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black"> 

### BackEnd

<img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white"> <img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"> 

### 형상 관리
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white"> <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">

<br/>

***ORM: Mybatis***

<br/>

## **⏰ 프로젝트 일정**


![스크린샷(1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/4f7ea0ba-3d55-4106-9672-da1fde38a496)

<br/><br/>

**참고 웹사이트:** https://happybean.naver.com/

<br/>

## **🔗 API명세서와 ERD설계도**

### API 명세서

https://third-tempo-8c0.notion.site/4b573b520b424c3590c6ce244e1df794?v=f2f7a9bebd714ea3be176765f004f3d2

<br/>

### ERD 설계도


<div align="center">
 
 ### 펀딩 ERD
 
</div>

![KakaoTalk_20230605_153904436](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/c6a471b0-85f3-4d27-a258-0ac460f730d4)

<br/><br/>

<div align="center">
 
 ### 기부 ERD

![KakaoTalk_20230605_154821409](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/86dc51b4-dca5-4fa9-bfb5-7398474b865f)


 
</div>

<br/><br/>

## **📝 메뉴구조도**

![스크린샷(2)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/263c80b5-0421-4bb8-b7ac-96c53100b837)

<br/>

## **✨ 화면 구현 및 코드 리뷰**

<br/>

### **회원가입 화면 구현 영상 및 코드 리뷰**

<details>
<summary>이메일 유효성 검사 영상과 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![이메일 유효성 검사](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/0bf30e4f-bf10-4864-a202-cba2c63a045d)

</br></br>

## FrontEnd

<br/>

**웹에서 이메일 입력 받기**

```html

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
            <Input id="input-with-icon-adornment"
                css={placeholderFontSize}
                label="email" 
                variant="outlined" 
                placeholder="이메일 주소 입력" 
                name="email" 
                type="text" 
                onChange={onChangeHandler} 
                startAdornment={
                    <InputAdornment position="start">
                    <Mail />
                    </InputAdornment>
                } />
                {emailSubmitDisabled ? (
                successMessage.email && <Alert css={errorCss} severity="success">{successMessage.email}</Alert>
            ) : (
                <>
                    {emailErrorMessage.email && <Alert css={errorCss} severity="error">{emailErrorMessage.email}</Alert>}
                    {errorMessage.email && <Alert css={errorCss} severity="error">{errorMessage.email}</Alert>}
                </>
            )}
        </FormControl>
        <Button variant="contained" css={checkedEmail} onClick={checkedEmailSubmit}>중복확인</Button>
    </div>

```

</br>

- input 창에 이메일 입력을 받고, 중복확인 버튼도 넣어준다.
- input 창에는 onChange, button에는 onClick을 넣어줌으로써 내가 취한 행동에 대한 값을 함수로 넘겨준다.

---

</br></br>

**입력 받은 값 처리**

```javascript

const onChangeHandler = (e) => {
    const { name, value } = e.target;
    setSignUp({...signUp, [name]: value});
}

```

</br>

- name에는 email, value에는 email이라는 이름을 가진 input창에 값이 들어가있다.
- 입력 받은 값을 setSignUp(useState로 렌더링이 될 때 마다 상태가 업데이트가 된다)에 데이터를 넣어준다.

---

</br></br>

**요청**

```javascript

    const checkedEmailSubmit = () => {
        checkDuplicateEmail.mutate();
    }

```

</br>

```javascript

const checkDuplicateEmail = useMutation(async () => {
    setErrorMessages({email: ""})

    const data = {
        email: signUp.email
    }
    const option = {
        headers: {
            "Content-Type": "application/json"
        }
    }

    try {
        await axios.post("http://localhost:8080/auth/checkemail", JSON.stringify(data), option)
        setSuccessMessage({email: <div css={availableEmail}>사용 가능한 이메일입니다.</div>})
        setEmailSubmitDisabled(true);
    }catch(error) {
        setEmailErrorMessage({email: error.response.data.errorData.email})
        setEmailSubmitDisabled(false);
    }
})

```

</br>

- useMutation을 사용해 요청을 보내면 상태 관리나 에러 처리 부분에 있어서 용이하다. 그래서 get 요청을 제외하고는 useMutation을 사용하여 요청을 보내는 것이 좋다.
  get 요청에 관한 것은 아래에서 다룰 것이다. 

- Javascript는 싱글 쓰레드이기 때문에 모든 코드가 비동기 처리로 돼서 요청에서 오류가 꽤 생길 수 있다. 예를 들어, 요청에 대한 코드 바로 다음에 응답으로 받은 데이터를 가지고 처리하는 코드가 있다 치자. 서버에 데이터 요청을 보내고 나서 응답이 오지도 않음과 동시에 필요한 데이터를 받지도 못했는데 다음 코드가 실행이 되는 상황이 생겨버린다. 그래서 비동기 처리 과정을 동기적인 것처럼 실행하기 위해 async 함수와 함께 await 키워드를 쓴다. (비동기 처리가 실제 동기 처리가 되는 것이 아니고, 동기와 유사하게 보이는 것임)

- 서버로 보낸 요청 데이터를 동기적인 것처럼 실행을 하고 싶기 때문에 await 뒤에 요청 url을 넣어준다.

- input 창에서 입력 받은 값을 요청 데이터로 보낸다.

- 만약 유효성 검사에서 에러 없이 성공적으로 처리가 됐다면 "사용 가능한 이메일입니다."를 띄워준다.

- 에러가 있다면 검사해서 떴던 에러 내용을 setEmailErrorMessage에 담는다.

- setEmailSubmitDisabled에 넣어준 상태 값은 아래 회원가입 성공에 설명이 있다.
  
---

</br></br>

## BackEnd

<br/>

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class SignUpController {
	
	private final SignUpService signUpService;
	
	@ValidAspect
	@PostMapping("/checkemail")
	public ResponseEntity<?> duplicatedEmail(@Valid @RequestBody DuplicatedEmailReqDto email, BindingResult bindingResult) {
		signUpService.duplicatedEmail(email.getEmail());
		return ResponseEntity.ok().body(true);
	}
	
}

```

</br>

- 프론트에서 보낸 email을 받아준다.
- Post요청(CRUD 중 Create)에 대한 데이터 처리.
- @Valid를 달아주면 dto 안에 있는 email(), Pattern() 등을 검사해준다.
- @Valid와 BindingResult는 세트임. signUpReqDto의 오류를 BindingResult에게 모두 넘겨준다.

---

</br></br>

**Dto**

```java

@Data
public class DuplicatedEmailReqDto {
	@Email
	@NotBlank(message="이메일을 입력하세요")
	private String email;
}

```

</br>

- @Email과 @NotBlank 등 validation과 관련된 어노테이션을 써주면 거기에 해당되는 메세지를 에러 메세지로 반환해준다. 

---

</br></br>

**Service**

```java

public void duplicatedEmail(String email) {
  if(signUpRepository.findUserByEmail(email) != null) {
    throw new CustomException("Duplicated Email", 
        ErrorMap.builder()
        .put("email", "사용 중인 email입니다.")
        .build());
  }
}

```

</br>

- Controller에서 보낸 email을 받아서 데이터베이스에 있는 이메일과 비교를 한다.
- 이메일이 존재한다면 따로 만들어준 CustomException이라는 객체와 ErrorMap이라는 객체에 "email"이라는 키와 "사용 중인 email입니다."라는 value를 넣어준다.
- 이 에러 메세지를 만들어줌으로써 프론트에서 이 메세지를 처리할 수 있게 된다.

---

</br></br>

**Repository**

```java

@Mapper
public interface UserRepository {
	public User findUserByEmail(String email);
}

```

</br>

- xml file로 대체
- interface를 써야 Mapper를 쓸 수 있고, mybatis에서 받을 수 있다.
- Service에서 보낸 email을 데이터베이스로 들고가서 확인을 한다.

---

</br></br>

**Sql**

```sql

<select id="findUserByEmail" resultMap="userMap">
  select
    ut.user_id,
    ut.email,
    ut.password,
    ut.name,
    ut.birth_day,
    ut.gender,
    ut.provider,
    ut.phone_number,
    
    at.authority_id,
    at.user_id,
    at.role_id,
    
    rt.role_id,
    rt.role_name
  from
    user_tb ut
    left outer join authority_tb at on(at.user_id = ut.user_id)
    left outer join role_tb rt on(rt.role_id = at.role_id)
  where
    ut.email = #{email}
</select>

```

</br>

- id는 Repository에 있는 findUserByEmail이고, 그 반환 값은 User 객체다.
- where문에는 user 테이블에 있는 email과 findUserByEmail에 매개변수 email을 받아서 비교해준다.
- 이 where문에서 이메일 비교를 했을 때, email이 존재하다면 위 Service에서 에러 메세지를 띄우게 되는 것.

---

</br></br>

**Database**

![이메일 확인 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/a2e41380-3059-4807-a2b4-3c60148afe85)

</br>

- 영상에서 보여졌던 dmlgus3585@gmail.com이라는 이메일이 이미 존재하다는 것을 사진을 통해 확인할 수 있다.

---
  
</div>
</details>

<details>
<summary>그 외 유효성 검사 및 회원가입 성공 영상과 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![그 외 유효성 검사 및 회원가입 성공](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/2dac8417-6567-427f-855a-fe6c728a2fd1)

</br></br>

## FrontEnd

**회원가입 정보 입력**

```html

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
	    <Input id="input-with-icon-adornment"
		css={inputMargin}
		label="password"
		variant="outlined"
		placeholder="8-16자의 영문 및 숫자, 특수문자를 모두 포함"
		name="password"
		type="password"
		onChange={onChangeHandler} 
		startAdornment={
		    <InputAdornment position="start">
		    <Lock />
		    </InputAdornment>
		} />
	    {errorMessage.password && <Alert css={errorCss} severity="error">{errorMessage.password}</Alert>}
    </FormControl>
</div>

<div css={signupInputContainerWrap}>
    <FormControl variant="standard">
	    <Input id="input-with-icon-adornment" 
		label="password" 
		variant="outlined" 
		placeholder="비밀번호 재입력" 
		name="confirmPassword" 
		type="password" 
		onChange={onChangeHandler} 
		startAdornment={
		    <InputAdornment position="start">
		    <Lock />
		    </InputAdornment>
		} />
	     {errorMessage.confirmPassword && <Alert css={errorCss} severity="error">{errorMessage.confirmPassword}</Alert>}
    </FormControl>
</div>

```

</br>

- 비밀번호 입력하는 부분만 예시로 넣었다. 나머지는 형식이 똑같음.

---

</br></br>

**입력 받은 값 처리**

```javascript

const onChangeHandler = (e) => {
    const { name, value } = e.target;
    setSignUp({...signUp, [name]: value});
}

```

</br>

- 위 내용에서 name, value에는 이메일만 들어간 모습을 보여주었지만 여기서는 이메일 포함 모든 입력 값들이 들어가있다
- 입력 받은 값을 setSignUp에 데이터를 넣어준다.

---

</br></br>

**요청**

```html

<div css={signUpBtnContainer}>
    <Button variant="contained" css={signupBtn} onClick={signUpSubmit}>가입하기</Button>
</div>

```

</br>

```javascript

    const signUpSubmit = () => {
        register.mutate();
    }

```

</br>

```javascript

    const register = useMutation(async () => {
        
        if (!emailSubmitDisabled) {
            setEmailErrorMessage({email: ""})
            setErrorMessages({ email: "이메일 중복 확인을 해주시기 바랍니다." });
            return;
        }

        if (signUp.password !== signUp.confirmPassword) {
            setErrorMessages({confirmPassword: "비밀번호가 일치하지 않습니다."});
            return;
        }
        const data = {
            ...signUp, ...address
        }

        const option = {
            headers: {
                "Content-Type": "application/json"
            }
        }
        try {
            await axios.post("http://localhost:8080/auth/signup", JSON.stringify(data), option)
            setErrorMessages({email: "", password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "", zonecode: "", address: "", detailAddress: ""})
            alert("회원가입 완료")
            window.location.replace("/login")
        }catch(error) {
            setErrorMessages({email: "", password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "",zonecode: "", address: "", detailAddress: "", ...error.response.data.errorData})
        }
    });

```

</br>

- 이메일 중복확인 부분에서 setEmailSubmitDisabled에 true나 false를 줬다. 만약 false인 경우 이메일 중복확인을 하지 않고 가입하기를 눌렀을 때 서버에서 데이터를 처리하기 어려워 이렇게 처리를 해줬다. 비밀번호 재입력 부분도 마찬가지.

- 여기서 주소 검색을 해서 주소가 들어갈 경우, 이전에 들어갔던 유저 정보들 상태가 초기화되는 문제가 생겼었다.(이 때까진 signUp 상태에 주소 정보까지 다 넣었었음)
어떻게 해도 안 되길래 결국 상태를 둘로 나눠서 요청을 보낸 것.

- 에러가 있을 경우 errorMeesages에 유효성 검사를 하면서 줬던 메세지가 입력이 되고 저장이 된다. 그리고 에러 없이 요청이 간 부분에는 에러 메세지를 공백으로 비워준다.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class SignUpController {
	
	private final SignUpService signUpService;

	@ValidAspect
	@PostMapping("/signup")
	public ResponseEntity<?> signup(@Valid @RequestBody SignUpReqDto signUpReqDto, BindingResult bindingResult) {
		signUpService.signUp(signUpReqDto);
		return ResponseEntity.ok().body(true);
	}
	
}

```

</br>

- 요청에서 받은 데이터로 유효성 검사 실시 후 성공하면 signUpService에 signUp에 넘긴다.

---

</br></br>

**Dto**

```java

@Data
public class SignUpReqDto {
	@Email
	@NotBlank(message="이메일을 입력하세요")
	private String email;
	
	@Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,16}$",
		message = "비밀번호는 영문자, 숫자, 특수문자를 포함하여 8 ~ 16자로 작성")
	private String password;
	
	@Pattern(regexp = "^[가-힣]{2,7}$",
		message = "이름은 한글 이름만 작성 	가능합니다.")
	private String name;
	
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
            	message = "생년월일을 형식에 맞게 작성해주세요.")
	private String birthday;
    
	@Pattern(regexp = "^(male|female)$",
            	message = "성별을 체크해주세요.")
	private String gender;
    
    	@Pattern(regexp = "^[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}$",
    		message = "휴대전화번호 형식에 맞게 작성해주세요.")
    	private String phoneNumber;
    
	@NotBlank(message = "우편번호는 필수 입력 값입니다.")
	private String zonecode;
	
	@NotBlank(message = "주소는 필수 입력 값입니다.")
	private String address;
	
	private String buildingName;
	private String bname;
	
	@NotBlank(message = "상세 주소는 필수 입력 값입니다.")
	private String detailAddress;
	
	private String addressType;
	
	public User toUserEntity() {
		return User.builder()
				.email(email)
				.password(new BCryptPasswordEncoder().encode(password))
				.name(name)
				.birthday(birthday)
				.gender(gender)
				.phoneNumber(phoneNumber)
				.build();
	}
	
	public Address toAddressEntity() {
		return Address.builder()
				.zonecode(zonecode)
				.address(address)
				.buildingName(buildingName)
				.bname(bname)
				.detailAddress(detailAddress)
				.addressType(addressType)
				.build();
	}
}

```

</br>

- 유효성 검사 실패 시에 띄워지는 메세지들이다.
- 데이터가 잘 들어왔다면 toUserEntity와 toAddressEntity에 유저 정보들이 들어간다.
- 비밀번호는 보안성을 위해 BCrypt로 바꿔줬는데, 이 BCrypt는 Spring Security에서 제공하는 비밀번호 암호화기이기 때문에 사용을 하기 위해서는 Bean에 등록이 되어야 한다.

```java

@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}

```

- 이 코드는 웹 관련해 보안을 다루는 객체를 따로 만들었는데 그건 아래 jwt와 oauth2, 관리자 페이지에서 같이 다룰 것이다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class SignUpService {
	
	private final UserRepository signUpRepository;
	private User userEntity;

	public int signUp(SignUpReqDto signUpReqDto) {
		userEntity = signUpReqDto.toUserEntity();
		signUpRepository.signUpUser(userEntity);

		signUpRepository.saveAuthority(
				Authority.builder()
				.userId(userEntity.getUserId())
				.roleId(1)
				.build());
		
		Address addressEntity = signUpReqDto.toAddressEntity();
		addressEntity.setUserId(userEntity.getUserId());
		
		
		return signUpRepository.saveAddress(addressEntity);
	}
}

```

</br>

- 데이터베이스에 주소 테이블에는 userId가 있는데 회원가입을 하고, 데이터를 확인해보니 주소 테이블에 userId가 계속 0이었다. 그래서 출력으로 하나씩 추적해서 찾아봤더니 머릿속으로는 이해가 되질 않아 이 방법 저 방법 써보다가 User 객체를 전역 변수로 빼니까 됐다!

- Authority는 유저의 권한을 의미하는 객체이고, roleId는 1번이 ROLE_USER, 2번이 ROLE_ADMIN이다. 그래서 이건 일반 회원가입이기 때문에 ROLE_USER를 부여해준 것.

- 반환 자료형은 성공 건수로 실패 시 0, 성공 시 1이기 때문에 int로 잡아줌.

---

</br></br>

**Repository**

```java
@Mapper
public interface UserRepository {
	public int saveAddress(Address address);
	public int signUpUser(User user);
	public int saveAuthority(Authority authority);
}

```

- Service에서 주소 정보, 유저 정보, 권한 정보 받음.

---

**Sql**

- 주소 정보 넣기

```sql

<insert id="saveAddress" 
	parameterType="com.webproject.crowdfunding.entity.Address"
	useGeneratedKeys="true"
	keyProperty="addressId">

	insert into address_tb
	values
	(0, #{userId}, #{zonecode}, #{address}, #{buildingName}, #{bname}, #{detailAddress}, #{addressType})
</insert>

```

</br>

- 유저 정보 넣기

```sql

<insert id="signUpUser"
	parameterType="com.webproject.crowdfunding.entity.User"
	useGeneratedKeys="true"
	keyProperty="userId">

	insert into user_tb
	values
	(0, #{email}, #{password}, #{name}, #{birthday}, #{gender}, #{provider}, #{phoneNumber})
</insert>

```

</br>
  
- 권한 정보 넣기

```sql

<insert id="saveAuthority" parameterType="com.webproject.crowdfunding.entity.Authority">
	insert into authority_tb
	values
	(0, #{userId}, #{roleId})
</insert>

```

</br>

- 반환 자료형을 넣어주고, insert가 된 후에 자동생성된 키값을 해당 id에 맞게 넣어주고 있다.

---

</br></br>

**Database**

- 유저 정보 데이터

![회원가입 성공 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/351f5483-cfac-4fcd-aa3e-7d9884bce0a1)

</br>

- 주소 정보 데이터

![주소 정보 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/28027045-fda0-4313-932d-96bbbd5a33b8)

</br>

- 권한 정보 데이터

![권한 정보 데이터](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/0ced2a4d-b50b-4dd8-93fe-8439e8a89c1d)

</br>

- 이렇게 데이터를 확인할 수 있다.

---
  
</div>
</details>

<br/>

### **로그인 화면 구현 영상 및 코드 리뷰**

<details>
<summary>로그인 유효성 검사 및 예외 처리 영상 그 외 토큰 부여 및 권한 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![로그인 유효성 검사 및 예외처리](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/f095cb2f-d0a7-4127-9279-44e37efbe79a)

</br></br>

## FrontEnd

**웹에서 로그인 정보 입력**

```html

    <div css={loginRightSide}>
	<div css={loginInputContainer}>
	    <div css={loginInputContainerWrapId}>
		<i css={inputI}></i>
		<FormControl variant="standard">
		    <Input id="input-with-icon-adornment" 
			label="email" 
			variant="outlined" 
			placeholder="email" 
			name="email" 
			type="text" 
			onChange={informationHandle} 
			startAdornment={
			    <InputAdornment position="start">
			    <Mail />
			    </InputAdornment>
			} />
		    {errorMessages.email && <Alert css={errorCss} severity="error">{errorMessages.email}</Alert>}
		</FormControl>
	    </div>
	    <div css={loginInputContainerWrapPw}>
		<i css={inputI}></i>
		<FormControl variant="standard">
		    <Input id="input-with-icon-adornment" 
			label="password" 
			variant="outlined" 
			placeholder="password" 
			name="password" 
			type="Password" 
			onChange={informationHandle}
			onKeyPress={handleOnKeyPress}
			startAdornment={
			    <InputAdornment position="start">
			    <Lock />
			    </InputAdornment>
			} />
		    {errorMessages.password && <Alert css={errorCss} severity="error">{errorMessages.password}</Alert>}
		</FormControl>
	    </div>
	</div>
	<div>
	    <button css={loginBtn} onClick={loginHandleSubmit}>로그인</button>
	</div>

```

</br>

- 아이디와 비밀번호를 입력한 후 로그인 버튼을 클릭하고, 오류가 있을 시에 에러 메세지를 띄우게 설계

---

</br></br>

**입력 받은 값 처리**

```javascript

    const informationHandle = (e) => {
        const { name, value } = e.target;
        setLoginUser({...loginUser, [name]: value})
    }

```

</br>

- 위에서 다뤘던 내용과 동일

---

</br></br>

**요청**

```javascript

    const login = useMutation(async() => {
        const option = {
            headers: {
                "Content-Type": "application/json"
            }   
        }
        try{
            const response = await axios.post("http://localhost:8080/auth/login", JSON.stringify(loginUser), option);
            setErrorMessages({email: "", password: ""});
            const accessToken = response.data.accessToken;
            localStorage.setItem("accessToken", accessToken); 
            setAuthenticated(true);
            window.location.replace("/");
        } catch(error) {
            setErrorMessages({email: "", password: "", ...error.response.data.errorData});
            if(error.response.data.message === "로그인 실패") {
                alert("사용자 정보를 확인해주세요.")
            }
        }
    })

    const loginHandleSubmit = () => {
        login.mutate();
    }

```

</br>

- 데이터가 성공적으로 들어갔으면 웹페이지를 이용할 수 있는 토큰을 부여한다.

- useRecoilState는 상태를 전역으로 관리를 하는 것.

</br>

```javascript

const [ authenticated, setAuthenticated ] = useRecoilState(authenticatedState);

```

</br>

```javascript


export const authenticatedState = atom({
    key: "authenticatedState",
    default: false
});

```

</br>

- 기본 값은 false이고, 상태 하나하나를 atom으로 보는 것인데 여기서 atom이란 하나의 상태를 나타내는 객체로 생각하면 된다.

- 데이터가 성공적으로 들어갔으면 기본 값이 false였던 것을 로그인 코드에서 true로 바꿔주는 것이다.

- 이 코드를 만든 이유는 로그인을 한 사람과 하지 않은 사람에게 다른 이용을 할 수 있도록 하기 위해 만들었다.

---

</br></br>

**권한이 필요한 웹페이지에 권한 부여**

```javascript

export const refreshState = atom({
    key: "refreshState",
    default: true
});

```

</br>

```javascript

const AuthRoute = ({ path, element }) => {
    const [ refresh, setRefresh ] = useRecoilState(refreshState);
    const accessToken = localStorage.getItem("accessToken");
    const navigate = useNavigate();

    const authenticated = useQuery(["authenticated"], async () => {
     const option = {
        headers: {
            Authorization: `Bearer ${accessToken}`
        }
     }
        try {
            const response = await axios.get("http://localhost:8080/auth/authenticated", option);
            return response;
        } catch(error) {
            localStorage.removeItem("accessToken");
            navigate("/login");
        }
    }, {
        refetchInterval: 1000 * 60
    });

    const principal = useQuery(["principal"], async () => {
        const option = {
            headers: {
                Authorization : `Bearer ${accessToken}`
            }
         }

        const response = await axios.get("http://localhost:8080/principal", option)
        return response;
        },{
            onSuccess: (response) => {
                const roles = response.data.authorities.split(",");
                if (path !== "/" && path.startsWith("/admin") && !roles.includes("ROLE_ADMIN")) {
                    alert("접근 권한이 없습니다.");
                    navigate("/");
                }
            },
            enabled: !!accessToken && !!authenticated.data
    });

    useEffect(() => {
        if(!refresh) {
            setRefresh(true);
        }
    }, [refresh]);
    
    

    if(authenticated.isLoading) {
        return <div>로딩중...</div>;
    }

    const permitAll = ["/login", "/signup", "/auth/oauth2/login", "/auth/oauth2/signup", "/auth/oauth2/merge"];

    if(!authenticated.data.data) {
        if(permitAll.includes(path)){
            return element;
        }
    }

    if(permitAll.includes(path)){
        navigate("/");
    }

    return element;
};

```

</br>

- useEffect를 사용함으로써 렌더링이 될 때 refresh가 false이면 true로 주면서, 강제로 작업을 수행할 수 있게 만들었다.

- 렌더링이 될 때 마다 로그인을 하면서 발급 받은 토큰를 1분(refetchInterval: 1000 * 60에서 1000은 1초를 의미한다) 마다 인증을 하는데, 토큰이 만료가 되거나 잘못된 형식 등 예외가 터지면 토큰을 제거하고 로그아웃을 시킨다.

- 렌더링이 될 때 마다 인증이 된 토큰을 보내는데, 이 토큰에는 유저의 정보들이 담겨 있다. 이 정보 속을 열어보면 부여해준 권한이 ROLE_ADMIN이 아닌데 웹 주소창에 /admin이라는 페이지를 강제로 열어서 접근을 했을 때 권한이 없다는 것을 알려준다.

- authenticated에서 인증되지 않은 사용자에 대해 permitAll에 있는 경로를 이용할 수 있게 하고, 인증된 사용자들은 저 경로를 이용할 수 없도록 메인 화면으로 보낸다.
이렇게 만들어준 이유는 인증이 됐다는 것은 로그인이 된 것을 의미하는데, 로그인이 된 사람이 다시 로그인 창을 들어가는 상황이나 회원가입을 하는 상황 등 옳지 않은 상황들을 생각하여 넣어줬다.

</br>

```javascript

function App() {
  return (
    <>
      <Global styles={Reset}></Global>
      <HeaderMain />
      <Routes>
        <Route path="/" element={<Main />} />
        <Route path="/login" element={<AuthRoute path="/login" element={<Login />} />} />
        <Route path="/signup" element={<AuthRoute path="/signup" element={<SignUp />}/>} />
        <Route path="/search" element={<Search />} />
        <Route path="/giving" element={<Giving />} />
        <Route path="/giving/:pageId" element={<GivingDetail />} />
        <Route path="/funding" element={<Funding />} />
        <Route path="/funding/:pageId" element={<FundingDetail />} />
        <Route path="/admin/register/page" element={<AuthRoute path="/admin/register/page" element={<RegisterPage />}/>} />
        <Route path='/auth/oauth2/login' element={<AuthRoute path={"/auth/oauth2/login"} element={<OAuth2Login />}/>} />
        <Route path='/auth/oauth2/signup' element={<AuthRoute path={"/auth/oauth2/signup"} element={<OAuth2SignUp />}/>} />
        <Route path='/auth/oauth2/merge' element={<AuthRoute path={"/auth/oauth2/merge"} element={<OAuth2Merge />}/>} />
      </Routes>
    </>
  );
}

```

</br>

- 경로 관련 app.js 코드다.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class LoginController {
	
	private final LoginService loginService;
	
	@ValidAspect
	@PostMapping("/login")
	public ResponseEntity<?> login(@Valid @RequestBody LoginReqDto loginReqDto, BindingResult bindingResult) {
		return ResponseEntity.ok(loginService.login(loginReqDto));
	}
	 
	@GetMapping("/authenticated")
	public ResponseEntity<?> authenticated(@RequestHeader(value = "Authorization") String accessToken) {
		return ResponseEntity.ok().body(loginService.authenticated(accessToken));
	}
}

```

- 값을 ok 안에 넣거나, body 안에 넣거나 똑같다. 하지만 badRequest는 안 됨. ok만 가능

---

</br></br>

**Dto**

```java

@Data
public class LoginReqDto {
	@Email(message = "존재하지 않는 이메일입니다.")
	@NotBlank(message="이메일을 입력하세요")
	private String email;
	
	@Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,16}$",
			message = "비밀번호는 영문자, 숫자, 특수문자를 포함하여 8 ~ 16자로 작성")
	private String password;
}

```

</br>

- 로그인 유효성 검사

---

**Service**

```java

@Service
@RequiredArgsConstructor
public class LoginService {

	private final AuthenticationManagerBuilder authenticationManagerBuilder;
	private final JwtTokenProvider jwtTokenProvider;
	private final PasswordEncoder passwordEncoder;
	private final UserRepository userRepository;
	
	public JwtRespDto login(LoginReqDto loginReqDto) {
		
		User userEntity = userRepository.findUserByEmail(loginReqDto.getEmail());
		
		if(userEntity == null || !passwordEncoder.matches(loginReqDto.getPassword(), userEntity.getPassword())) {
			throw new CustomException("로그인 실패", ErrorMap.builder().put("login", "사용자 정보를 확인하세요").build());
		}
		
		UsernamePasswordAuthenticationToken authenticationToken = 
				new UsernamePasswordAuthenticationToken(loginReqDto.getEmail(), loginReqDto.getPassword());
		Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
		return jwtTokenProvider.generateToken(authentication);
	}
	
	public boolean authenticated(String accessToken) {
		return jwtTokenProvider.validateToken(jwtTokenProvider.getToken(accessToken));
	}
}

```

- 먼저, 데이터베이스에서 저장되어있는 이메일을 들고와서 현재 로그인 하려는 이메일과 비교를 했을 때 일치하지 않거나, 정보가 없으면 에러메세지를 띄우게 했다. 

- 그 다음 UsernamePasswordAuthenticationToken을 선언해주면서 로그인한 아이디와 비밀번호를 가지고 인증 토큰을 하나 만든다.

- 그 토큰을 가지고 authenticationManagerBuilder.getObject().authenticate(authenticationToken)에다 넣어주는데 여기서부터 스프링부트 내에서 authenticationManagerBuilder가 이 토큰 정보를 가지고 loadByUsername라는 함수를 실행시킨다.

```java

@Service
@RequiredArgsConstructor
public class PrincipalDetailsService implements UserDetailsService {

	private final UserRepository signUpRepository;

	@Override
	public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
		User userEntity = signUpRepository.findUserByEmail(email);
		return userEntity.toPrincipal();
	}

}

```

</br>

- 위를 실행시킨다는 의미인데, 여기는 로그인 정보를 담고 있는 부분이다.

- 반환하고 있는 toPrincipal을 보자면 아래와 같이 되어있다.

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
	private int userId;
	private String email;
	private String password;
	private String name;
	private String birthday;
	private String gender;
	private String provider;
	private int addressId;
	private String phoneNumber;
	private List<Authority> authorities;
	
	public PrincipalUserDetails toPrincipal() {
		return PrincipalUserDetails.builder()
				.userId(userId)
				.email(email)
				.password(password)
				.roles(authorities)
				.build();
	}
}

```

</br>

```java

@Getter
@Builder
public class PrincipalUserDetails implements UserDetails{

	private static final long serialVersionUID = -8654755481982862798L;
	
	private int userId;
	private String email;
	private String password;
	private List<Authority> roles;
	
	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		List<SimpleGrantedAuthority> authorities = new ArrayList<>();
		roles.forEach(role -> {
			authorities.add(new SimpleGrantedAuthority(role.getRole().getRoleName()));
		});
		return authorities;
	}

	@Override
	public String getPassword() {
		return password;
	}

	@Override
	public String getUsername() {
		return email;
	}

	// 사용기간 만료 = false
	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	// 계정을 잠궈버림 = false
	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	// 비밀번호 5회 틀렸을 때 잠궈버림 = false
	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	// 계정 비활성 상태(이메일 인증을 완료해야 하거나 또는 전화번호 인증을 하지 않았을 때) = false
	@Override
	public boolean isEnabled() {
		return true;
	}

}

```

</br>

- 권한 객체를 생성해준다.

- 권한 목록을 반환, List가 Collection으로 업캐스팅됨

- User 객체에서 Builder를 이용해 값들을 넣어준 다음, 권한 객체까지 만들어주면 이제 Service에서 Authentication이라는 객체가 생성이 된다.

</br>

위 코드를 보면 생성된 Authentication 객체를 jwtTokenProvider.generateToken에 넣어주는데, 이제 jwtTokenProvider로 가보자.

```java

@Component
public class JwtTokenProvider {
	@Autowired
	private UserRepository userRepository;
	private final Key key;

	public JwtTokenProvider(@Value("${jwt.secret}") String secretKey) {	// @Component일 때 사용 가능. yml의 key값이 매개변수로 들어간다
		key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
	}

	public JwtRespDto generateToken(Authentication authentication) {
		StringBuilder builder = new StringBuilder();
		authentication.getAuthorities().forEach(authority -> {
			builder.append(authority.getAuthority() + ",");		// 문자열 사용가능, role이 하나씩 나온다.

		});

		builder.delete(builder.length() - 1, builder.length());		// ~부터 ~까지 지워라. 쉼표를 지우기 위해 씀

		String authorities = builder.toString();	// role 권한들을 문자열로 바꾸기 위해서

		Date tokenExpiresDate = new Date(new Date().getTime() + (1000 * 60 * 60));	// 1000 * 60을 하면 1분이다. 그래서 1시간을 만료 시간으로 설정

		String accessToken = Jwts.builder()
				.setSubject(authentication.getName())	// 토큰의 제목(큰이름), getName() = email
				.claim("auth", authorities)	// 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터들로 모두 선택적으로 작성이 가능함
				.setExpiration(tokenExpiresDate)	// 토큰의 만료기간
				.signWith(key, SignatureAlgorithm.HS256)	// 토큰 암호화
				.compact();

		return JwtRespDto.builder().grantType("Bearer").accessToken(accessToken).build();	// 이후 controller가 받는다.

	}

	// Bearer를 뗀 토큰 값을 풀어서 검사함.
	public boolean validateToken(String token) {
		try {
			Jwts.parserBuilder()	// Jwt 형태를 Json이 아닌 java 형태로 쓰겠다
			.setSigningKey(key)		// token이 만들어진 key로 되어있는지 확인
			.build()
			.parseClaimsJws(token);		// 유효성 검사

			return true;

		// Security 라이브러리에 오류가 있거나, JSON의 format이 잘못된 형식의 JWT가 들어왔을 때 예외
		}catch (SecurityException | MalformedJwtException e) {
		}catch (ExpiredJwtException e) {
		}catch(UnsupportedJwtException e) {
		}catch(IllegalArgumentException e) {
		}catch(Exception e) {

		}

		// 예외가 일어나면 인증되지 않았다, 쓸 수 없는 토큰이다
		return false;
	}
	// 요청할 때 토큰을 Bearer ~~~~~~~~~~라는 값으로 보내는데, 토큰값만 넘겨주기 위해 앞에 Bearer를 잘라주는 과정.
	// 토큰 앞에 Bearer를 붙인 이유는 개발자끼리의 약속이라고 한다.
	public String getToken(String token) {
		String type = "Bearer ";
		if(StringUtils.hasText(token) && token.startsWith(type)) {
			return token.substring(type.length());
			
		}
		return null;
		
	}
	public Claims getClaims(String token) {
		return Jwts.parserBuilder()
				.setSigningKey(key)
				.build()
				.parseClaimsJws(token)
				.getBody();
	}
	
	public Authentication getAuthentication(String accessToken) {
		Authentication authentication = null;
		
		Claims claims = getClaims(accessToken);		// Claims 통째로 들고오기

		// Spring에서 기본적으로 지원해주는 UserDedatils임
		// new User(username, password, 권한) == PrincipalDetails
		// password는 공개되면 안 되기 때문에 공백이다
		User user = userRepository.findUserByEmail(claims.getSubject());
		PrincipalUserDetails principalUserDetails = user.toPrincipal();
		
		// new UsernamePasswordAuthenticationToken(User객체, 자격 증명 객체(SSL 등 회사든 공공에서든 인증서가 필요할 때. https에서 증명할 때 쓰임), 권한)
		// return하면 업캐스팅이 돼서 Authentication 객체가 된다. UsernamePasswordAuthenticationToken를 타고 들어가면 Authentication을 implement 하고 있다.
		// 임시의 Authentication 객체가 생성
		authentication = new UsernamePasswordAuthenticationToken(principalUserDetails, null, principalUserDetails.getAuthorities());
		return authentication;
	}
}

```

</br>

- 여기에다가 정리하려니 복잡해서 한 줄 주석으로 정리를 했다. 이제 토큰이 잘 가공이 되면 JwtRespDto라는 객체가 반환이 되는데 코드는 아래와 같다.

```java

@Builder
@Data
public class JwtRespDto {
	private String grantType;
	private String accessToken;

}

```

</br>

- 이제 로그인할 때 필요한 인증을 거치고, 인증의 표시인 토큰까지 발급을 받게 되면 웹페이지에서 권한이 들어간 서비스를 사용할 수 있게 된다.

이제 종합적으로 보면

1. Service에서 아이디와 비밀번호를 가지고 인증에 필요한 토큰을 하나 만든다.
2. 그 토큰으로 데이터베이스에 있는 유저가 맞는지 이메일로 확인을 한다.
3. 이메일 확인이 되면 userId, 이메일, 비밀번호, 권한 내용까지 반환을 한다.
4. Authentication이라는 객체가 생성이 되면서 유저가 인증이 된 것이다.
5. 생성된 Authentication 객체의 정보를 jwtTokenProvider.generateToken에 넘기는데 여기서 토큰을 가공을 해준다.
6. 이상없이 가공이 끝나면 가공된 토큰을 Controller로 반환을 해주고 웹에서 받는다.

---
  
</div>
</details>

<br />

### **펀딩 메인 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>1. 카테고리 적용 영상</summary>
<div markdown="1">
  
![카테고리 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/402755b6-cfc9-4570-8a93-0c4274a2d2e8)

  
</div>
</details>

<details>
<summary>2. 정렬(전체, 진행중, 종료) 영상</summary>
<div markdown="1">

![정렬(전체, 진행중, 종료)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/8b3de60f-18f2-4500-bc2b-12b6f255214b)
  
</div>
</details>

<details>
<summary>3. 정렬(최신 순, 참여 금액 순, 참여율 순, 종료 임박 순) 영상</summary>
<div markdown="1">
<br/>

- 최신 순
  
![최신 순 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/6ee7a5ac-fa0e-491a-ab49-4d046c3c7a93)

<br/><br/>

- 참여금액 순
  
![참여 금액 순 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/2c598491-a31d-4f0b-887e-b296e686cd10)

<br/><br/>

- 참여율 순

![참여율 순 - Clipchamp로 제작 (1)](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/8034d691-c756-449c-b0fe-bd40a648a002)

<br/><br/>

- 종료 임박 순

![종료 임박 순 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/edbb6514-334a-4ae8-a8a5-dff336992268)
  
</div>
</details>

<details>
<summary>카테고리 관련 코드 리뷰</summary>
<div markdown="1">

## FrontEnd

**요청**

- 메인 페이지에 쓸 것

```javascript
    const [ searchParam, setSearchParam ] = useState({page: 1, fundingSortingReward: "최신 순", fundingSortingStatus: "전체"});
    const [ refresh, setRefresh ] = useState(true);

    const fundingData = useQuery(["fundingData"], async () => {
        const option = {
            params : {
                ...searchParam
            }
        }
        const response = await axios.get("http://localhost:8080/funding/main", option);
        return response;
    }, {
        enabled: refresh,
        onSuccess: () => {
            setRefresh(false);
        }
    });

```

</br>

- 카테고리에 쓸 것

```javascript

    const fundingCategorys = useQuery(["fundingCategory"], async () => { 
        return await axios.get("http://localhost:8080/funding/category");
    });

```

</br>

- post요청을 보낼 땐 useMutation을 썼는데 여기서는 useQuery를 쓰는 모습을 볼 수 있다. 먼저, useMutation은 post, put, delete와 같은 요청을 처리하는 데에 있어서 쓸 수 있고, useQuery는 데이터를 조회할 때 사용하기 때문에 get 요청에 쓰인다. useQuery도 마찬가지로 상태관리나 에러 처리에 있어서 용이하기에 사용을 한다.

- searchParam은 페이지네이션과 정렬을 가공하기 위해 요청 데이터로 보냈다.

- enabled는 요청을 활성화할 것인지 비활성화를 할 것인지 결정을 한다. 초기값에 true를 넣어줌으로써 처음 요청을 보내는데 활성화를 시키고, 요청이 오고나면 onSuccess가 작동을 해 다시 refresh를 false로 주면서 enabled를 비활성화 시키는 모습을 볼 수 있다. 이는 데이터를 처음 한 번만 가져오면서 에러를 최소화를 시킬 수 있고, 로딩 시간도 짧게 할 수 있기 때문에 사용을 했다.

---

</br></br>

**펀딩 메인 페이지 html 코드**

```html

<div>
    <div css={welcomeFunding}><FundingSlide /></div>
    <div css={fundingMain}>
	<div css={fundingHeader}>
	    <button css={fundingCategoryMainButton} onClick={() => handleCategoryClick(null)}>전체</button>
	    {fundingCategorys.isLoading ? <div>...불러오는 중</div> : fundingCategorys.data.data.map(fundingCategory => (
		<div css={fundingCategoryContainer}>
		    <button css={fundingCategoryButton}
			    onClick={() =>handleCategoryClick(fundingCategory.fundingCategoryId)}
			    key={fundingCategory.fundingCategoryId}>
			{fundingCategory.categoryName}
		    </button>
		</div>
	    ))}
	</div>
	    <div css={sortingFundingStatusContainer}>
		<div css={fundingStatusDetail} onClick={statussortingHidden}>
		    <button css={fundingStatus}>{sortingStatus}</button>
		    <div>{statusHiddenFlag ? "△" : "▽"}</div>
		    {statusHiddenFlag ? (<ul css={sortingFundingStatusList}>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>전체</li>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>진행중</li>
			<li css={sortingFundingStatus} onClick={sortingStatusHandle}>종료</li>
		    </ul>) : ""}
		</div>
		<div css={fundingStatusDetail} onClick={rewardsortingHidden}>
		    <button css={fundingStatus}>{sortingReward}</button>
		    <div>{rewardHiddenFlag ? "△" : "▽"}</div>
		{rewardHiddenFlag ? (<ul css={sortingFundingRewardStatusList}>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>최신 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>참여 금액 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>참여율 순</li>
		    <li css={sortingFundingReward} onClick={sortingRewardHandle}>종료 임박 순</li>
		</ul>) : ""}
		</div>
	    </div>
	<div css={fundingMainConatiner}>
	    {fundingData.data.data.fundingList.filter(
	    funding => selectedCategoryId === null ||
	    funding.fundingCategoryId === selectedCategoryId).map(funding => (
		<div css={fundingContainer} onClick={() => {fundingDetailHandle(funding.pageId)}}>
		    <div>
			<div css={imgBox}>
			    <img css={img} src={`http://localhost:8080/image/main/${funding.mainImgUrl}`} />
				<div css={checkFunding({funding})}>
				    <div css={fundingTxt}>펀딩</div>
				    <div>{funding.joinPercent >= 100 ? "성공" : "종료"}</div>
				</div>
			</div>
		    </div>
			<div key={funding.pageId}>
			    <div css={fundingContainerMainTitlePrice}>
				<div css={fundingContainerMainTitlePageTitle}>{funding.pageTitle}</div>
				<div css={fundingContainerMainPricePadding}>
				    <div css={fundingContainerMainPrice}>{funding.joinPercent}%</div>
				</div>
			    </div>
			    <div css={fundingContainerMainUsername}>{funding.fundingSummaryName}</div>
			</div>
		    <div css={fundingContainerFooter}>
			    <div css={fundingContainerFooterEventStatus}>{funding.eventStatus}</div>
			    <div css={fundingContainerFooterPrice}>{new Intl.NumberFormat('en-US').format(funding.totalRewardPrice)}원</div>
		    </div>
		</div>
	    ))}
	</div>
	<div>
	    <div css={pageNationContainer}>
		<div css={pageNationIndex} onClick={loadMore}>더보기</div>
	    </div>
	</div>
	    <div css={footerContainer}>
		<Footer />
	    </div>
    </div>
</div>

```

</br>

- 카테고리에 전체만 따로 빼놓은 이유는 현재 데이터베이스에는 전체라는 카테고리가 존재하지 않아 따로 처리해주었다. onClick 속성 안에 handleCategoryClick은 categoryId를 넘겨준다.

- 정렬 방식에서 열림과 닫힘을 넣기 위해 클릭 시에 작동하는 true false 상태를 주었다.

- 펀딩 기간이 종료가 됐을 때 펀딩 금액이 목표 금액에 100퍼센트 미만일 경우에 종료, 이상일 경우에 성공을 줌으로써 유저들이 종료된 펀딩 상품들의 가치를 쉽게 파악할 수 있다.

- 나머지는 데이터베이스에서 들고온 데이터들을 그대로 넣어준 것.

---

</br></br>

**응답 받은 데이터 가공**

```javascript

    const handleCategoryClick = (categoryId) => {
        setSelectedCategoryId(categoryId);
    };

    const statussortingHidden = () => {
        if(statusHiddenFlag) {
            setStatusHiddenFlag(false);
        }else {
            setStatusHiddenFlag(true);
        }
    }

    const rewardsortingHidden = () => {
        if(rewardHiddenFlag) {
            setRewardHiddenFlag(false);
        }else {
            setRewardHiddenFlag(true);
        }
    }

    const sortingStatusHandle = (e) => {
        const statusText = e.target.textContent;
        setSearchParam({...searchParam, fundingSortingStatus: statusText, page: 1})
        setSortingStatus(statusText);
        setStatusHiddenFlag(false);
        setRefresh(true);
    }

    const sortingRewardHandle = (e) => {
        const rewardText = e.target.textContent;
        setSearchParam({ ...searchParam, fundingSortingReward: rewardText, page: 1});
        setSortingReward(rewardText);
        setRewardHiddenFlag(false);
        setRefresh(true);
    };

    const fundingDetailHandle = (pageId) => {
        navigate("/funding/" + pageId);
    }

    const loadMore = () => {
        if(!refresh) {
            setSearchParam({ ...searchParam, page: searchParam.page + 1});
            setRefresh(true);
        }
    };

```

</br>

- 카테고리 선택에 보면 html에서 카테고리 버튼을 누르면 해당 카테고리 id가 들어가는데 그러면 그 id에 해당하는 목록들만 보여진다. 초기 값은 null인데 아무것도 누르지 않은 null인 상태면 전부 다 보여지는 전체 카테고리도 만들었다.

- 정렬 버튼 열고 닫기

- 정렬의 상태가 바뀌면 바뀐 값을 넣어주면서 상태를 업데이트함.

- 보고 싶은 펀딩의 상세 내용이 궁금해 클릭을 하면 펀딩 상세페이지로 이동을 한다.

- 더보기를 누를 때 마다 index가 0부터 1씩 증가하는데 자세한 페이지네이션 기능은 아래 코드 리뷰에서 진행할 것이다. 

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/funding")
public class FundingMainController {
 
	private final FundingService fundingService;
	
	@GetMapping("/main")
	public ResponseEntity<?> fundingData(FundingEventReqDto fundingMainReqDto) {
		System.out.println(fundingMainReqDto);
		return ResponseEntity.ok(fundingService.toSaveFunding(fundingMainReqDto));
	}
	
	@GetMapping("/category")
	public ResponseEntity<?> fundingCategory() {
		return ResponseEntity.ok(fundingService.fundingCategory());
	}
	
}

```

- 위에서 보낸 요청 데이터를 받고 Service로 넘긴다.

---

</br></br>

**Dto**

```java

@Data
public class FundingEventReqDto {
	private int page;
	private String fundingSortingReward;
	private String fundingSortingStatus;
}

```

- 요청에서 보낸 것처럼 기본 값으로 page: 1, fundingSortingReward: 최신 순, fundingSortingStatus: 전체가가 들어간다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class FundingService {
	private final FundingRepository fundingRepository;
	
	public Map<String, Object> toSaveFunding(FundingEventReqDto fundingEventReqDto) {
		List<FundingMainRespDto> fundingList = new ArrayList<>();

		int index = (fundingEventReqDto.getPage() * 20) - 1;
		Map<String, Object> eventStatusMap = new HashMap<>();
		eventStatusMap.put("index", index);
		eventStatusMap.put("fundingSortingReward", fundingEventReqDto.getFundingSortingReward());
		eventStatusMap.put("fundingSortingStatus", fundingEventReqDto.getFundingSortingStatus());
		
		fundingRepository.saveFunding(eventStatusMap).forEach(funding -> {
			fundingList.add(funding.toSaveFunding());
		});
		
		Map<String, Object> responseMap = new HashMap<>();
		responseMap.put("fundingList", fundingList);
		return responseMap;
	}
	
	public List<FundingCategoryRespDto> fundingCategory() {
		List<FundingCategoryRespDto> fundingCategorys = new ArrayList<>();
		
		fundingRepository.getFundingCategory().forEach(fundingCategory -> {
			fundingCategorys.add(fundingCategory.fundingCategoryToDto());
		});
		return fundingCategorys;
	}
	
	
}

```

- FundingMainRespDto, FundingCategoryRespDto에는 펀딩 메인페이지에 필요한 sql에서 가공한 데이터가 들어간다. 많은 데이터가 담겨있기 때문에 List로 담았다.

- page는 더보기를 클릭할수록 20개씩 보여지기 위해 page가 1부터 증가할 때 마 20을 곱하도록 했다.

- Map을 써준 이유는 프론트에서 데이터를 파악하기 쉽게 value에 걸맞은 key 값을 설정을 해주고 있다.

- 나머지도 sql에서 가공한 데이터를 들고온다.

- 뒤에서도 이런 형식의 코드를 주로 사용할 것이다.

---

</br></br>

**ResponseDto**

- 펀딩 메인

```java

@Builder
@Data
public class FundingMainRespDto {
	private int pageId;
	private String fundingSummaryName;
	private String pageTitle;
	private int recentSort;
	private String nearDeadlineSort;
	private String eventStatus;
	private int goalTotal;
	private int totalRewardPrice;
	private int joinPercent;
	private String mainImgUrl;
	private int fundingCategoryId;
}

```

</br>

- 펀딩 메인 페이지에 사용할 것들이다. 순서대로
  	- pageId는 상세 페이지 이동을 위해 넣어줌.

  	- fundingSummaryName은 기업체에서 사용하는 닉네임을 뜻함.

  	- pageTitle은 펀딩 제목.
  	
   	- recentSort는 최신 순부터 숫자로 표시했다.
  	
   	- nearDeadlineSort는 종료 임박 순을 숫자로 표시했다.
  	
   	- eventStatus는 종료까지 남은 일 수를 표시해준다.
  	
   	- goalTotal은 목표 금액.
  	
   	- totalRewardPrice는 펀딩한 사람들의 총 금액이다.
  	
   	- joinPercent는 목표 금액 대비 참여한 금액 수의 총 퍼센트이다.
  	
   	- mainImgUrl은 펀딩에 들어갈 이미지다.
  	
   	- fundingCategoryId는 카테고리 테이블에 있는 categoryId.

---

</br>

- 펀딩 카테고리

```java

@Data
@Builder
public class FundingCategoryRespDto {
	private int fundingCategoryId;
	private String categoryName;
}

```

- 카테고리 테이블에 있는 것. 내용은 아래 Database에 사진을 첨부할 것이다. 

---

</br></br>

**Entity**

- Funding

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Funding {
	private int fundingId;
	private int userId;
	private String fundingTitle;
	private LocalDate endDate;
	private String fundingSummaryName;
	private String username;
	private int recentSort;
	private String nearDeadline;
	private String eventStatus;
	private int goalTotal;
	private int totalRewardPrice;
	private int joinPercent;
	private String mainImgUrl;
	private String subImgUrl;
	private int fundingCategoryId;
	private String storyTitle;
	private String storyContent;
	
	public FundingMainRespDto toSaveFunding() {
		return FundingMainRespDto.builder()
				.pageId(fundingId)
				.fundingSummaryName(fundingSummaryName)
				.pageTitle(fundingTitle)
				.recentSort(recentSort)
				.nearDeadlineSort(nearDeadline)
				.eventStatus(eventStatus)
				.goalTotal(goalTotal)
				.totalRewardPrice(totalRewardPrice)
				.joinPercent(joinPercent)
				.mainImgUrl(mainImgUrl)
				.fundingCategoryId(fundingCategoryId)
				.build();
	}
}

```

</br>

- Funding 객체에 메인 페이지와 상세 페이지에서 쓸 것들을 한 번에 모아놨다.

- 위에서 다룬 것처럼 펀딩 메인 페이지에 사용될 것들만 따로 toSaveFunding이란 것을 만들었는데, 나머지는 상세 페이지에서 다룰 것이다.

- Builder를 이용하여 sql에서 가공한 것들을 Funding 객체로 반환을 하고, 가공된 것들을 다시 FundingMainRespDto에 담아서 반환을 한다. 

---

</br></br>

**Repository**

```java

@Mapper
public interface FundingRepository {
	public List<FundingCategory> getFundingCategory();
	public List<Funding> saveFunding(Map<String, Object> eventStatusMap);
}

```

</br>

- 카테고리는 요청 데이터 없이 데이터베이스에서만 필요한 데이터를 들고와야 하기 때문에 매개변수가 없음.

- 위에서 key와 value를 설정해줬는데, 이는 아래 sql문에서 사용될 것이다.

---

</br></br>

**Sql**

- 전체

```sql

<select id="saveFunding" parameterType="hashMap" resultMap="FundingMap">

	<if test="fundingSortingStatus == '전체'">
		select 
		    fpt.funding_id AS page_id,
		    fpt.funding_summary_name,
		    fpt.funding_name AS page_title,
	      	    DATEDIFF(NOW(), fpt.register_date) as recent_sort,
		    DATEDIFF(fpt.end_date, NOW()) as near_deadline_sort,
		    CONCAT(
		    IF(NOW() &lt; fpt.end_date,  CONCAT(DATEDIFF(fpt.end_date, NOW()), '일 남음'), IF(DATEDIFF(NOW(), fpt.end_date) = 0, '오늘 마감', '종료'))
		    ) AS event_status,
	            fpt.goal_total,
		    IFNULL(sum(if(ft.funder_id is null, null, rt.reward_price)), 0) as total_reward_price,
		    IFNULL(ROUND((sum(if(ft.funder_id is null, null, rt.reward_price)) / fpt.goal_total) * 100), 0) as join_percent,
		    fpt.main_img_url AS main_img_url,
		    fpt.funding_category_id
		from
		   funding_page_tb fpt
		    left outer join reward_tb rt on(rt.funding_id = fpt.funding_id)
		    left outer join funder_tb ft on(ft.reward_id = rt.reward_id)
		    left outer join funding_category_tb fct on(fct.funding_category_id = fpt.funding_category_id)

		<if test="fundingSortingReward == '종료 임박 순'">
		where
		    DATEDIFF(fpt.end_date, NOW()) >= 0
		</if>

		group by
		    page_id,
	            funding_summary_name,
	            page_title,
	            recent_sort,
	            near_deadline_sort,
		    event_status,
	            goal_total,
	            main_img_url,
	            funding_category_id

		<if test="fundingSortingReward == '최신 순'">
		order by
		    recent_sort,
		    page_id DESC
		limit 0, #{index};
		</if>
	
		<if test="fundingSortingReward == '참여 금액 순'">
		order by
		    total_reward_price DESC,
		    page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '참여율 순'">
		order by
		    join_percent DESC,
		    page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '종료 임박 순'">
		order by
		    DATEDIFF(fpt.end_date, NOW()),
		    page_id
		limit 0, #{index};
		</if>
	</if>

```

</br>

- 진행중

```sql

	<if test="fundingSortingStatus == '진행중'">
		select 
	            fpt.funding_id AS page_id,
		    fpt.funding_summary_name,
		    fpt.funding_name AS page_title,
		    DATEDIFF(NOW(), fpt.register_date) as recent_sort,
		    DATEDIFF(fpt.end_date, NOW()) as near_deadline_sort,
		    CONCAT(
		    IF(NOW() &lt; fpt.end_date,  CONCAT(DATEDIFF(fpt.end_date, NOW()), '일 남음'), IF(DATEDIFF(NOW(), fpt.end_date) = 0, '오늘 마감', '종료'))
		    ) AS event_status,
		    fpt.goal_total,
		    IFNULL(sum(if(ft.funder_id is null, null, rt.reward_price)), 0) as total_reward_price,
		    IFNULL(ROUND((sum(if(ft.funder_id is null, null, rt.reward_price)) / fpt.goal_total) * 100), 0) as join_percent,
		    fpt.main_img_url AS main_img_url,
		    fpt.funding_category_id
		from
		    funding_page_tb fpt
	            left outer join reward_tb rt on(rt.funding_id = fpt.funding_id)
	            left outer join funder_tb ft on(ft.reward_id = rt.reward_id)
	   	    left outer join funding_category_tb fct on(fct.funding_category_id = fpt.funding_category_id)
		where
		    DATEDIFF(fpt.end_date, NOW()) >= 0
		group by
		    page_id,
		    funding_summary_name,
		    page_title,
		    recent_sort,
		    near_deadline_sort,
		    event_status,
		    goal_total,
		    main_img_url,
		    funding_category_id
			
		<if test="fundingSortingReward == '최신 순'">
		order by
		    recent_sort,
		    page_id DESC
		limit 0, #{index};
		</if>	
		
		<if test="fundingSortingReward == '참여 금액 순'">
		order by
		    total_reward_price DESC,
		    page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '참여율 순'">
		order by
		    join_percent DESC,
		    page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '종료 임박 순'">
		order by
		    DATEDIFF(fpt.end_date, NOW()),
		    page_id
		limit 0, #{index};
		</if>
	</if>

```

</br>

- 종료

```sql

	<if test="fundingSortingStatus == '종료'">
		select 
			fpt.funding_id AS page_id,
			fpt.funding_summary_name,
			fpt.funding_name AS page_title,
			DATEDIFF(NOW(), fpt.register_date) as recent_sort,
			DATEDIFF(fpt.end_date, NOW()) as near_deadline_sort,
			CONCAT(
			IF(NOW() &lt; fpt.end_date,  CONCAT(DATEDIFF(fpt.end_date, NOW()), '일 남음'), IF(DATEDIFF(NOW(), fpt.end_date) = 0, '오늘 마감', '종료'))
			) AS event_status,
			fpt.goal_total,
		    IFNULL(sum(if(ft.funder_id is null, null, rt.reward_price)), 0) as total_reward_price,
			IFNULL(ROUND((sum(if(ft.funder_id is null, null, rt.reward_price)) / fpt.goal_total) * 100), 0) as join_percent,
			fpt.main_img_url AS main_img_url,
			fpt.funding_category_id
		from
		   funding_page_tb fpt
			left outer join reward_tb rt on(rt.funding_id = fpt.funding_id)
			left outer join funder_tb ft on(ft.reward_id = rt.reward_id)
			left outer join funding_category_tb fct on(fct.funding_category_id = fpt.funding_category_id)
		where
			DATEDIFF(fpt.end_date, NOW()) &lt; 0
		group by
		   	page_id,
            		funding_summary_name,
			page_title,
            		recent_sort,
            		near_deadline_sort,
			event_status,
			goal_total,
			main_img_url,
			funding_category_id
			
		<if test="fundingSortingReward == '최신 순'">
		order by
			recent_sort,
			page_id DESC
		limit 0, #{index};
		</if>	
		
		<if test="fundingSortingReward == '참여 금액 순'">
		order by
			total_reward_price DESC,
			page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '참여율 순'">
		order by
			join_percent DESC,
			page_id
		limit 0, #{index};
		</if>
		
		<if test="fundingSortingReward == '종료 임박 순'">
		order by
		    DATEDIFF(fpt.end_date, NOW()),
		    page_id
		limit 0, #{index};
		</if>
	</if>

</select>

```

</br>

- 3가지 다 형식이 똑같아서 "전체"만 다뤄보겠다.

- join
	- reward 테이블에는 해당 펀딩의 리워드와 그 금액들이 들어가있다.
   
  	- funder 테이블에는 펀딩한 사람들의 목록들이 있다.
  	
   	- 이를 토대로 해당 펀딩을 한 사람들의 총 금액과 목표 금액 대비 퍼센트를 구할 수 있다.
 
- 조회
	- recentSort가 위에서 말했던 최신 순인데 이는 오늘 날짜에서 등록 날짜를 빼준다. 그럼 숫자가 작을수록 최신 순이 된다.

  	- nearDeadlineSort는 종료 임박 순인데 이는 종료 날짜에서 오늘 날짜를 빼준다. 그럼 숫자가 작을수록 종료 임박순이 된다. 이 숫자를 토대로 디데이를 설정할 수 		있는데, 문제가 오늘 날짜일 때와 종료 날짜가 지났을 때 0과 -1~ 이렇게 떠버렸다. 그래서 조건으로 평상시에는 ~일 남음이라고 문자열을 합치고, 오늘 날짜에서 종료 	날짜를 뺐을 때 0이면(D-Day) 오늘 마감, 아니면(기간이 지났을 때) 종료로 설정을 해주었다.
  	
   	- funder_id가 null이면(펀딩을 한 사람이 없다.) null을 반환한다. 이는 0을 반환하는 것임. funder_id가 존재하면 그 유저가 펀딩한 리워드의 가격을 모두 합산함.
  	
   	- 위를 토대로 목표 금액 대비 퍼센트를 나타내기 위해 만들어줬다. 퍼센트를 구한 후, 소수점 제거를 위해 Round 함수를 썼다.
  	
   	- 나머지는 조회에서 보여준 대로 조건에 맞게 정렬을 걸어줬다.
  	
   	- 마지막은 페이지네이션을 걸어주기 위해 limit을 사용했는데 예를 들어 limit 0, 19면 0부터 19까지 총 20개만 출력이 된다. 그 다음 페이지가 늘어서 0부터 39, 0
  	  부터 59 이런 식으로 나오게 된다.
  	  
---

</br></br>

**Database**

- 펀딩 메인 페이지 테이블

![펀딩 메인 페이지](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/78cb3dee-00d1-4ada-8dd4-91356545692a)

</br>

- 최신 순 정렬

![최신 순](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/f19ec76e-63ca-4cbb-ad17-eebaf3f5b4e5)

</br>

- 리워드 테이블

![리워드](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/b1e3542c-cf36-4e2b-8219-04c3b6fd0916)

</br>

- 펀딩한 사람 테이블

![펀딩한 사람](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/11a6b9d0-35c2-448e-a999-debdbedd4072)
  
</div>
</details>

<br/>

### **펀딩 상세 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>현재 진행 중인 펀딩 영상</summary>
<div markdown="1">

![상세페이지 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/03dbfdd9-aa06-49b6-ae18-cbc3eb8a917a)

</div>
</details>

<details>
<summary>펀딩 참여하기(결제) 영상 및 코드 리뷰, HTTP 보안 설정</summary>
<div markdown="1">

![결제 처음 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/efa13972-cf36-46ce-8d24-88ef1951057a)

<br/><br/>

![KakaoTalk_20230624_165355960_01](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/3fab79c9-46f7-4985-8761-4cdb7d354bed)

<br/><br/>

![KakaoTalk_20230624_165355960_02](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/bf156ff1-3fbe-4c58-aba3-f42d68983b0c)

<br/><br/>

![KakaoTalk_20230624_165355960_03](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/d8413386-8d92-42d4-a32c-69af3ceb6727)

<br/><br/>

--- 결제 시스템 ---

구글에서 리액트 아임포트 검색 ->

https://velog.io/@gunilna/%ED%8F%AC%ED%8A%B8%EC%9B%90-Front-end-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0

</br> 

포트원 검색 ->

https://portone.io/korea/ko?utm_source=google&utm_medium=google_sa&utm_campaign=pf_conversion_2302_kr&utm_content=homepage&gclid=CjwKCAjwvdajBhBEEiwAeMh1U6u6y3g3vQLBloftPyxVmnOSARlJ2tDDjQz4Yon9REbYIoPVpeeAKBoCAvQQAvD_BwE 

</br>

-> 회원가입 및 로그인 -> 결제 연동 -> 내 식별 코드 -> 가맹점 식별 코드가 중요함! -> 결제 대행사 설정 -> 테스트, 카카오페이, 카카오페이

</br>

https://portone.gitbook.io/docs/tip/pg-2

pg사는 이걸 참고하면 된다.

</br>

https://portone.gitbook.io/docs/sdk/javascript-sdk/payrq

이걸 기준으로 내가 받고 싶은 데이터로 받으면 됨

결제가 완료 되면

https://admin.portone.io/payments

여기서 확인 가능.

테스트는 무료임

</br></br>

## FrontEnd

**결제 서비스**

```javascript

    const [ authenticated, setAuthenticated ] = useRecoilState(authenticatedState);

    useEffect(() => {
        const iamport = document.createElement("script");
        iamport.src = "https://cdn.iamport.kr/v1/iamport.js"
        document.head.appendChild(iamport);
        return () => {
            document.head.removeChild(iamport);
        }
    });

    useEffect(() => {
        if (accessToken) {
          setAuthenticated(true);
        } else {
          setAuthenticated(false);
        }
    }, []);

    const joinFunding = () => {
        if (!authenticated) {
            alert("로그인 후 이용 가능합니다.")
            navigate('/login');
        } else if (rewards.length === 0) {
            alert("리워드 수량과 옵션을 확인해주세요.");
        } else {
            setIsOpen(true);
        }
    }

    const joinSubmitHandle = () => {
        if (!window.IMP) return;
        /* 1. 가맹점 식별하기 */
        const { IMP } = window;
        IMP.init("imp26700005"); // 가맹점 식별코드

        /* 2. 결제 데이터 정의하기 */
        const data = {
            pg: "kakaopay", // PG사 : https://portone.gitbook.io/docs/sdk/javascript-sdk/payrq#undefined-1 참고
            pay_method: "kakaopay", // 결제수단
            merchant_uid: `mid_${new Date().getTime()}`, // 주문번호
            amount: totalPrice, // 결제금액
            name: funding.fundingTitle, // 주문명
            buyer_name: principalUser.data.data.name, // 구매자 이름
            buyer_tel: principalUser.data.data.phoneNumber, // 구매자 전화번호
            buyer_email: principalUser.data.data.email, // 구매자 이메일
            buyer_addr: getAddress.data.data.address // 구매자 주소
        };

        const rewardIds = [];
        const counts = [];
        rewards.map(reward => (rewardIds.push(reward.fundingReward.rewardId), counts.push(reward.fundingReward.count)));

        /* 4. 결제 창 호출하기 */
        IMP.request_pay(data, (response) => {
            const { success, error_msg } = response;

            if (success) {
                alert("결제 성공");
                joinFund.mutate({
                    userId: principalUser.data.data.userId,
                    addressId: getAddress.data.data.addressId,
                    rewardIds: rewardIds,
                    counts: counts
                });
            } else {
                alert(`결제 실패: ${error_msg}`);
            }
        });
    };

```

</br>

- useEffect에서 아임포트 서비스를 사용할 수 있는 환경을 구축한다.

- 펀딩 참여하기 버튼을 클릭했을 때 로그인이 된 유저 즉, 인증이 된 유저에 한해서만 가능하도록 설정을 했다. 인증이 되지 않았으면 버튼을 클릭했을 때 로그인 화면으로 보내게 하고, 수량과 옵션을 선택하지 않고 클릭을 하면 alert창을 띄우게 했다. authenticated는 위 로그인 코드 리뷰에 app.js 코드가 있는데 거기에 authenticated에 관한 코드가 작성되어 있어서 참고하면 된다. 이 웹페이지가 한 번 렌더링이 될 때 토큰으로 authenticated를 true나 false 상태로 업데이트할 수 있다.

- window.IMP 객체를 사용하여 결제 창을 연다. 객체가 없을 경우 결제 실패로 돌아가는데 이 서비스를 로드하기 위해 useEffect 코드를 만든 것이다.

- 아래 코드에서 가공한 것들을 넣어서 요청을 보낸다.

---

</br></br>

**요청**

```javascript

    const joinFund = useMutation(async (funder) => {
        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        return await axios.post("http://localhost:8080/auth/funding/payment", funder, option);
    }, {
        onSuccess: () => {
            alert("펀딩에 성공하였습니다.");
            setIsOpen(false);
        }
    });

```

</br>

- 결제하는 유저의 정보를 데이터베이스에 반영하기 위해 post 요청을 보낸다.

---

</br></br>

## BackEnd

**WebMvcConfig**

```java

@Configuration
public class WebMvcConfig implements WebMvcConfigurer{
	
	@Override
	public void addCorsMappings(CorsRegistry registry) {
		registry.addMapping("/**") // 3000포트에서 들어오는 모든 요청들 
				.allowedMethods("*")
				.allowedOrigins("*");
	}

```

</br>

- 원래는 Controller에 @CrossOrigin이라는 어노테이션을 달아줘야 한다. 매 번 어노테이션을 달기엔 번거롭기에 이런 설정법이 있다.

- 이 설정을 해주는 이유를 간략히 얘기하자면, 웹 애플리케이션에서 기본적으로 보안상의 이유로 요청을 차단을 한다. 그래서 요청을 허용하기 위해 Cross-Origin 설정을 필수로 해줘야 한다.

---

</br></br>

**SecurityConfig**

```java

public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	private final JwtTokenProvider jwtTokenProvider;
	private final OAuth2SuccessHandler oAuth2SuccessHandler;
	private final OAuth2Service oAuth2Service;
	private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
	
	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	// HTTP 보안 설정을 구성
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.cors();	// Cross-Origin Resource Sharing (CORS)를 활성화.
		http.csrf().disable();		// CSRF(Cross-Site Request Forgery) 보호 기능을 비활성화.
		http.httpBasic().disable();	// HTTP 기본 인증을 비활성화.
		http.formLogin().disable();	// form 기반의 로그인에 대해 비활성화.

		// 세션을 생성하지 않고 상태를 유지하지 않는 세션 관리 정책을 설정.
		http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

		// 요청에 대한 허용 설정
		http.authorizeRequests()
			.antMatchers("/image/**", "/funding/**", "/giving/**", "/main/**", "/page/**")	 // 특정 URL 패턴에 대한 접근 권한을 설정
			.permitAll()		// 위 URL 요청은 모두 허용
			.antMatchers("/auth/funding/**", "/auth/giving/**", "/admin/**")
			.authenticated()	// 위 URL 요청은 모두 인증이 필요
			.and()
			.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class)	// JWT 인증을 처리하는 				필터
			.exceptionHandling()
			.authenticationEntryPoint(jwtAuthenticationEntryPoint)		//  인증 진입 지점 설정

```

</br>

- jwt 인증 관련해서 로그인에 코드를 풀어놨다.

- 간략하게 보자면, 서버에 요청을 따라 들어올 때 요청 주소가 인증이 필요한지 안 필요한지 확인을 하고, 인증이 필요한 부분은 로그인 정보를 통해 인증을 한다. 인증이 필요 없는 URL은 인증 절차 없이 요청이 그대로 들어온다. 그래서 인증 절차가 필요없는 요청에 관한 건 로그인을 하지 않은 사람들도 모두 볼 수 있는 것들로 설정을 했고, 인증이 필요한 부분은 아무나 사용할 수 없도록 결제와 관리자 페이지에서 들어오는 요청에 설정을 해줬다.

---

</br></br>

**Controller**

```java

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {
	
	private final AuthService authService;

	@PostMapping("/funding/payment")
	public ResponseEntity<?> toPaymentInfo(@RequestBody FunderReqDto funderReqDto) {
		return ResponseEntity.ok(authService.saveFunder(funderReqDto));
	}
}

```

</br>

- 요청으로 받은 데이터를 넘기고 응답을 하고 있다.

---

</br></br>

**Dto**

```java

@Data
public class FunderReqDto {
	private int userId;
	private int addressId;
	private List<Integer> rewardIds;
	private List<Integer> counts;
	
	public List<Funder> toFunderEntity() {
	    List<Funder> funders = new ArrayList<>();
	    for (int i = 0; i < counts.size(); i++) {
	        int rewardId = rewardIds.get(i);
	        int count = counts.get(i);
	        	for (int j = 0; j < count; j++) {
		            Funder funder = Funder.builder()
		                    .userId(userId)
		                    .addressId(addressId)
		                    .rewardId(rewardId)
		                    .build();
		            funders.add(funder);
	        	}
	    	}
	    return funders;
	}
}

```

</br>

- 리워드의 개수가 List로 들어오기 때문에 개수에 맞춰 for문을 돌려준 후 하나씩 값을 넣어준 후, 새로운 List에 추가를 하고 반환을 하고 있다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class AuthService {
	
	private final AuthRepository authRepository;
	
	public int saveFunder(FunderReqDto funderReqDto) {
		List<Funder> funderEntity = funderReqDto.toFunderEntity();
		return authRepository.toSaveFunder(funderEntity);
	}
 }

```

</br>

- 서버로 데이터를 보내기 위해 Repository로 넘겨주고 있다.

---

</br></br>

**Repository**

```java

@Mapper
public interface AuthRepository {
	public int toSaveFunder(List<Funder> funder);
}

```

</br>

- sql문을 작성하기 위해 Funder 객체를 넣어준다.

---

</br></br>

**Sql**

```sql

<insert id="toSaveFunder"
	parameterType="com.webproject.crowdfunding.entity.Funder"
	keyProperty="funderId"
	useGeneratedKeys="true">
	insert into funder_tb
	values
	<foreach collection="list" item="funder" separator=",">
		(0, #{funder.userId}, NOW(), #{funder.addressId}, #{funder.rewardId})
	</foreach>
</insert>

```

</br>

- foreach를 돌려 리스트를 하나씩 꺼내서 insert한다.

- 이제 결제한 사람들의 정보가 데이터베이스에 들어가게 된다.

---

</br></br>

**Database**

![Funder](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/d2b3687f-47c0-4f99-8520-141bc0ad6646)

</br>

- 결제창에서 총 6개를 선택했는데, 여기에도 6개가 잘 들어간 모습을 볼 수 있다.

---

</div>
</details>

<details>
<summary>종료된 펀딩 영상</summary>
<div markdown="1">

![종료된 펀딩](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/238f395c-98bc-4262-99c6-e3ce59013b34)

</div>
</details>

<details>
<summary>펀딩 상세 페이지 코드 리뷰</summary>
<div markdown="1">

</br>

## FrontEnd

**요청**

- 주요 내용

```javascript

    const fundingDetail = useQuery(["fundingDetail"], async () => {
        return await axios.get(`http://localhost:8080/fundingdetail/${pageId}`);
    });

    const fundingDetailReward = useQuery(["fundingDetailReward"], async () => {
        return await axios.get(`http://localhost:8080/fundingdetail/reward/${pageId}`);
    });

    const fundingBusinessInfo = useQuery(["fundingBusinessInfo"], async () => {
        return await axios.get(`http://localhost:8080/fundingdetail/businessinfo/${pageId}`);
    })

    const fundingJoinBreakdown = useQuery(["fundingJoinBreakDown"], async () => {
        return await axios.get(`http://localhost:8080/fundingdetail/breakdown/${pageId}`);
    })

```

</br>

- 로그인한 유저에 대한 정보 확인

```javascript

    const principalUser = useQuery(["principalUser"], async () => {
        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        const response = await axios.get("http://localhost:8080/principal", option)
        setRole(response.data.authorities.split(",").includes("ROLE_ADMIN"));
        return response;
    },{
        enabled: !!accessToken
    })

    const getAddress = useQuery(["getAddress"], async () => {
        const option = {
            params: {
                userId: principalUser.data.data.userId
            },
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        return await axios.get("http://localhost:8080/fundingdetail/address", option);
    }, {
        enabled: !!principalUser.data
    })

```

</br>

- 현재 경로의 URL 매개변수를 들고오기 위해 변수명을 pageId로 한 useParams를 받아줬다.

- 나머지는 백에서 가공된 데이터를 들고올 것이다.

- 유저에 대한 정보를 들고온 이유는 결제할 때 유저의 정보가 필요해서 들고왔다.

---

</br></br>

**펀딩 상세 페이지 html 코드**

```html

        <div>
            <div css={fundingDetailContainer}>
                <div css={fundingDetailHeader}>
                    <img css={fundingDetailImg} src={`http://localhost:8080/image/main/${funding.mainImgUrl}`} />
                    <div css={fundingDetailHeaderRight}>
                        <div css={fundingDetailNearDeadline}>{funding.deadline === "종료" ? "종료" : funding.deadline === "오늘 마감" ?  "오늘 마감" : `D-${funding.deadline}`}</div>
                        <div css={fundingDetailFundingTitle}>{funding.fundingTitle}</div>
                        <div css={fundingDetailJoinPercent}>{funding.joinPercent}%</div>
                        <progress css={fundingDetailJoinPercentProgress} value={funding.joinPercent} max="100"/>
                        <div css={fundingDetailTotal}>
                            <div css={fundingDetailGoalTotal}>{new Intl.NumberFormat('en-US').format(funding.goalTotal)}원 목표</div>
                            <div css={fundingDetailTotalRewardPrice}>{new Intl.NumberFormat('en-US').format(funding.totalRewardPrice)}원</div>
                        </div>
                        <div css={funderName}>{funding.fundingSummaryName}</div>
                        <div css={fundingDetailRewardContainer}>
                            <div css={SelectFundingDetail}>
                                <button css={SelectRewardButton} onClick={selectRewardHandle}>
                                    <div css={SelectRewardTxt}>리워드 선택하기</div>
                                    <div css={SelectRewardArrow}>{selectRewardHidden ? "△" : "▽"}</div>
                                </button>
                                {selectRewardHidden ? (<ul css={SelectRewardList}>
                                    {fundingDetailReward.data.data.rewardList.map(fundingReward => (
                                        <li css={SelectRewardName} 
                                            onClick={() => selectRewardNameHandle(fundingReward)}>{fundingReward.rewardName}</li>
                                        ))}
                                        </ul>) : ""}
                                    {rewards.map(reward =>(
                                            <div css={rewardsMain} key={reward.fundingReward.rewardId}>
                                                <div css={rewardNameAndDelete}>
                                                    <div css={rewardsName}>{reward.fundingReward.rewardName}</div>
                                                    <button css={rewardsDeleteButton} onClick={() => deleteRewardHandle(reward)}>X</button>
                                                </div>
                                                <div css={rewardCountAndPriceContainer}>
                                                    <div css={rewardButtonAndPrice}>
                                                        <button css={minusButton}
                                                                onClick={() => decreaseCount(reward)}>-</button>
                                                        <input  css={rewardCount}
                                                                type="number"
                                                                value={reward.fundingReward.count || 1}
                                                                onChange={(e) => countHandle(e, reward)} />
                                                        <button css={plusButton}
                                                                onClick={() => increaseCount(reward)}>+</button>
                                                    </div>
                                                    <div css={rewardsPrice}>{new Intl.NumberFormat('en-US').format(reward.fundingReward.rewardPrice)}원</div>
                                                </div>
                                            </div>
                                    ))}
                                <div css={TotalReward}>
                                    <div css={TotalRewardCount}>총 수량 {totalQuantity}개</div>
                                        <div css={TotalRewardPriceContainer}>
                                            <div css={TotalRewardPriceTxt}>총 금액</div>
                                            <div css={TotalRewardPrice}>{new Intl.NumberFormat('en-US').format(totalPrice)}원</div>
                                        </div>
                                </div>
                            </div>
                        </div>
                        <div css={joinFundingButtonContainer}>
                            {funding.deadline === "종료" ?
                            <button css={endFundingButton}>펀딩 종료하기</button> :
                            <button css={joinFundingButton} onClick={joinFunding}>펀딩 참여하기</button>}
                            {isOpen ?
                                <div css={joinFundContainer}>
                                    <div css={joinFundIdentifyContainer}>
                                        <div css={joinFundIdentifyMain}>
                                            <div css={joinFundHeader}>
                                                <div css={joinFundTitle}>{funding.fundingTitle}</div>
                                                <div css={joinFundNickname}>By UniSecond</div>
                                            </div>
                                            <div css={joinFundBorderBottom}>
                                            {rewards.map(reward => (
                                                <div css={joinFundRewardContainer} key={reward.fundingReward.rewardId}>
                                                    <div css={joinFundRewardName}>{reward.fundingReward.rewardName}</div>
                                                    <div css={joinFundCountAndPrice}>
                                                        <div css={joinFundCount}>수량: {reward.fundingReward.count}개</div>
                                                        <div css={joinFundPrice}>가격: {new Intl.NumberFormat('en-US').format(reward.fundingReward.rewardPrice)}원</div>
                                                    </div>
                                                </div>
                                            ))}
                                            </div>
                                            <div css={paymentTxtContainer}>
                                                <div css={paymentTxt}>결제를 진행하시겠습니까?</div>
                                            </div>
                                            <div css={joinTotalRewardPriceContainer}>
                                                <div css={joinTotalRewardPriceTxt}> 총 금액:</div>
                                                <div css={joinTotalRewardPrice}>{new Intl.NumberFormat('en-US').format(totalPrice)}원</div>
                                            </div>
                                            <div css={joinIdentifyButtonContainer}>
                                                <button css={joinIdentifyButton} onClick={joinSubmitHandle}>결제하기</button>
                                                <button css={joinCancelButton} onClick={joinCancelButtonHandle}>취소</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            : ""}
                        </div>
                    </div>
                </div>
            </div>
            <div css={storyHeadLine}>
                <div css={storyHeadLineContainer}>
                    <div css={storyTxt}>스토리</div>
                </div>
            </div>
            <div css={fundingStoryContainer}>
                <div css={fundingStory}>
                    <div css={fundingStoryTitle}>{funding.storyTitle}</div>
                    <div css={fundingStoryContent}>{funding.storyContent}</div>
                    <img css={fundingStoryImg} src={`http://localhost:8080/image/sub/${funding.subImgUrl}`} />
                </div>
                <div css={rewardGuide}>
                    <div css={txtGuide}>리워드 안내</div>
                    {fundingDetailReward.data.data.rewardList.map(reward => (
                        <div css={rewardGuideList} key={reward.rewardId}>
                            <div css={rewardGuidePriceAndJoin}>
                                <div css={rewardGuidePrice}>{new Intl.NumberFormat('en-US').format(reward.rewardPrice)}원</div>
                                <div css={rewardGuideJoin}>펀딩 참여</div>
                            </div>
                            <div css={rewardGuideInfo}>
                                <div css={rewardGuideRewardName}>{reward.rewardName}</div>
                                <div css={rewardGuideDetailContainer}>
                                    <li css={rewardGuideDetailInfo}>현재 {reward.userCount}명 참여</li>
                                    <li css={rewardGuideDetailInfo}>발송 예상일 {reward.endDate}</li>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            <div css={joinUserContainer}>
                <div css={joinUserMain}>
                    <div css={joinUserContent}>
                        <div css={joinBreakdownTxt}>참여내역</div>
                        <div css={joinBreakdownCount}>
                            <div css={joinBreakdownTotalCount}>총 {fundingJoinBreakdown.data.data.breakdownList.length}명</div>
                            <div css={joinBreakdownJoinTxt}>이 참여하였습니다.</div>
                        </div>
                        {fundingJoinBreakdown.data.data.breakdownList.map(breakdown => (
                            <div>
                                <div css={joinBreakdownUserContainer}>
                                    <div css={joinBreakdownUser}>{breakdown.username}님</div>
                                    <div css={joinBreakdownUserPrice}>{new Intl.NumberFormat('en-US').format(breakdown.totalRewardPrice)}</div>
                                    <div css={joinBreakdownPriceTxt}>원 참여</div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div css={businessInfoContainer}>
                <div css={businessInfoMain} key={businessInfo.fundingId}>
                    <div css={businessInfoPadding}>
                        <div css={businessInfoTxt}>사업자 정보</div>
                        <div css={businessInfoContent}>
                            <div css={businessInfoDetailContent}>상호명: {businessInfo.companyName}</div>
                            <div css={businessInfoDetailContent}>대표자: {businessInfo.ceoName}</div>
                            <div css={businessInfoDetailContent}>사업자 소재지: {businessInfo.companyAddress}</div>
                            <div css={businessInfoDetailContent}>고객센터: {businessInfo.companyPhoneNumber}</div>
                            <div css={businessInfoDetailContent}>이메일: {businessInfo.ceoEmail}</div>
                        </div>
                    </div>
                </div>
            </div>
            <div css={fundingDetailFooter}>
                <Footer />
            </div>
        </div>

```

- 여기서 따로 처리해준 거라곤 날짜 관련해서 디데이 설정과 종료가 되면 펀딩 참여하기 버튼을 종료로 바꾼 것이고, 나머지는 서버에서 들고온 데이터를 넣어준 것.

---

</br></br>

**응답 받은 데이터 가공**

```javascript

    const [ selectRewardHidden, setSelectRewardHidden ] = useState(false);
    const [ rewards, setRewards ] = useState([]);
    const [ totalQuantity, setTotalQuantity ] = useState(0);
    const [ totalPrice, setTotalPrice ] = useState(0);

    const selectRewardNameHandle = (fundingReward) => {
        const isDuplicate = rewards.some(reward => reward.fundingReward.rewardId === fundingReward.rewardId);
        if (isDuplicate) {
          alert("이미 등록된 상품입니다.");
          setSelectRewardHidden(false);
        } else {
          setSelectRewardHidden(false);
          setRewards([...rewards, { fundingReward: { ...fundingReward, count: 1 } }]);
          setTotalQuantity(quantity => quantity + 1);
          setTotalPrice(price => price + fundingReward.rewardPrice)
        }
    }

    const deleteRewardHandle = (reward) => {
        const deletedRewardCount = reward.fundingReward.count || 1;
        const deletedRewardPrice = reward.fundingReward.rewardPrice;
        console.log(deletedRewardPrice);
        const newRewards = rewards.filter(r => r.fundingReward.rewardId !== reward.fundingReward.rewardId);
        setRewards(newRewards);
      
        setTotalQuantity(quantity => quantity - deletedRewardCount);
        setTotalPrice(price => price - deletedRewardPrice);

        reward.fundingReward.count = 1;
      }
    
    const decreaseCount = (reward) => {
        const newRewards = [...rewards];
        const rewardIndex = newRewards.findIndex(r => r.fundingReward.rewardId === reward.fundingReward.rewardId);
        
        if (rewardIndex !== -1) {
          const count = newRewards[rewardIndex].fundingReward.count || 1;
          if (count > 1) {
            const rewardPrice = reward.fundingReward.rewardPrice;
            const priceDecrease = rewardPrice / count;
            newRewards[rewardIndex].fundingReward.count = count - 1;
            newRewards[rewardIndex].fundingReward.rewardPrice -= priceDecrease;
            setTotalQuantity(quantity => quantity - 1);
            setTotalPrice(price => price - priceDecrease);
          }
        }
        
        setRewards(newRewards);
      }


    const countHandle = (e, reward) => {
        const newRewards = [...rewards];
        const rewardIndex = newRewards.findIndex(r => r.fundingReward.rewardId === reward.fundingReward.rewardId);

        if (rewardIndex !== -1) {
            const count = parseInt(e.target.value, 10);
            const prevCount = newRewards[rewardIndex].fundingReward.count || 1;

            if (!isNaN(count) && count >= 1) {
            const diffCount = count - prevCount;
            newRewards[rewardIndex].fundingReward.count = count;

            if (diffCount !== 0) {
                const prevPrice = newRewards[rewardIndex].fundingReward.rewardPrice;
                const newPrice = prevPrice * (count / prevCount);
                newRewards[rewardIndex].fundingReward.rewardPrice = newPrice;
            }

            setRewards(newRewards);

            const updatedTotalQuantity = newRewards.reduce((total, r) => total + (r.fundingReward.count || 1), 0);
            const updatedTotalPrice = newRewards.reduce((total, r) => total + (r.fundingReward.rewardPrice), 0);
            console.log(updatedTotalPrice);
            setTotalQuantity(updatedTotalQuantity);
            setTotalPrice(updatedTotalPrice);
            }
        }
    };

    const increaseCount = (reward) => {
        const newRewards = [...rewards];
        const rewardIndex = newRewards.findIndex(r => r.fundingReward.rewardId === reward.fundingReward.rewardId);
        if (rewardIndex !== -1) {
          newRewards[rewardIndex].fundingReward.count = (newRewards[rewardIndex].fundingReward.count || 1) + 1;
          const count = newRewards[rewardIndex].fundingReward.count;
          if (count >= 1) {
            const rewardPrice = reward.fundingReward.rewardPrice;
            const priceIncrease = rewardPrice / (newRewards[rewardIndex].fundingReward.count - 1);
            newRewards[rewardIndex].fundingReward.rewardPrice += priceIncrease;
            setTotalQuantity(quantity => quantity + 1);
            setTotalPrice(price => price + priceIncrease);
        }
    }
        setRewards(newRewards);
    };

```

- selectRewardNameHandle
	- 매개 변수로 받은 fundingReward에는 해당 펀딩의 리워드들이 들어가있다.

  	- rewards는 서버에서 들고온 리워드들을 담기 위해 새로운 배열 상태를 하나 만들어주었다. fundingReward로 해결하려니 오류가 많아 고민 끝에 새로운 배열 상태를 	만드는 걸로 결정했다.

  	- 그래서 이 둘을 비교하여 새로운 배열에 담겨있는 걸 또 담으려고 할 경우에 이미 등록된 상품이라고 처리를 하고, 중복이 되지 않다면 그걸 rewards에 새로 담고 		기본 수량을 1로 설정.
   
 	- 나머지는 총 수량을 다 더해줌으로써 표시를 해줄 수 있다. 예를 들어 리워드가 총 3개일 경우에 기본 수량 하나씩 다 더해줘서 총 수량이 1이 된다. 총 금액도 마		찬가지.

- deleteRewardHandle
	- 지금부터는 위에서 새로운 배열에 리워드들을 담았기 때문에 그것들을 가공할 것이다.
   
	- deletedRewardCount 변수는 삭제된 리워드의 개수를 나타낸다. reward.fundingReward.count 값이 존재하면 해당 값을 사용하고, 그렇지 않으면 기본값인 1을 사용		한다.
   
	- deletedRewardPrice 변수 역시 삭제된 리워드의 가격을 나타낸다.
   
 	- newRewards 변수는 rewards 배열에서 삭제된 리워드를 제외한 새로운 배열을 생성한다. filter 함수를 사용하여 reward.fundingReward.rewardId와 일치하지 않는 		리워드만을 남겨둔다.
    
	- setRewards(newRewards)를 호출하여 rewards 상태 값을 새로운 배열로 업데이트한다. 이를 통해 삭제된 리워드가 제외된 새로운 리워드 목록을 반영하게 된다. 
 
- decreaseCount
	- newRewards 변수는 rewards 배열을 얕은 복사하여 새로운 배열을 생성한다. 이를 통해 기존 배열을 직접 수정하지 않고 업데이트할 수 있다.

  	- rewardIndex 변수는 newRewards 배열에서 reward.fundingReward.rewardId와 일치하는 보상의 index를 찾는다. findIndex 메서드를 사용하여 리워드를 찾을 수 없는 	경우 -1을 반환한다.

	- rewardIndex가 -1이 아닌 경우, 즉 리워드를 찾은 경우에만 아래의 코드 실행한다.

	- count 변수는 리워드의 개수를 나타낸다. 만약 newRewards[rewardIndex].fundingReward.count 값이 존재하지 않으면 기본값인 1을 사용한다.

	- count가 1보다 큰 경우, 즉 개수를 감소시킬 수 있는 경우에만 아래의 코드를 실행한다.

	- rewardPrice 변수는 리워드의 가격을 나타낸다. reward.fundingReward.rewardPrice 값을 사용한다.

	- priceDecrease 변수는 각 개수 감소에 따라 감소되어야 할 가격을 계산한다. 즉, 보상의 가격을 현재 개수로 나눈 값이다.

	- newRewards[rewardIndex].fundingReward.count 값을 1 감소시킨다.

	- newRewards[rewardIndex].fundingReward.rewardPrice에서 priceDecrease를 뺀 값을 할당하여 리워드의 가격을 업데이트한다.

	- setTotalQuantity(quantity => quantity - 1)를 호출하여 totalQuantity 상태 값을 1 감소시킨다.

	- setTotalPrice(price => price - priceDecrease)를 호출하여 totalPrice 상태 값을 priceDecrease만큼 감소시킨다.

	- setRewards(newRewards)를 호출하여 rewards 상태 값을 업데이트한다.

	- 이를 통해 decreaseCount 함수는 리워드의 개수를 1 감소시키고, 개수에 따라 가격을 조정하여 rewards, totalQuantity, totalPrice 값을 업데이트한다.

- countHandle
	- count 변수는 정수로 변환하여 할당한다.

	- prevCount 변수는 이전에 저장된 리워드의 개수를 나타낸다.

	- diffCount 변수는 변경된 개수와 이전 개수의 차이를 나타낸다.

	- newRewards[rewardIndex].fundingReward.count 값을 변경된 개수로 업데이트한다.

	- newPrice 변수는 이전 가격에 변경된 개수의 비율을 곱한 값을 나타낸다.

	- newRewards[rewardIndex].fundingReward.rewardPrice 값을 newPrice로 업데이트하여 보상의 가격을 조정한다.

	- setRewards(newRewards)를 호출하여 rewards 상태 값을 업데이트한다.

	- newRewards 배열이 돌면서 보상의 개수를 합산하여 updatedTotalQuantity를 계산한다.

	- newRewards 배열이 돌면서 보상의 가격을 합산하여 updatedTotalPrice를 계산한다.

	- setTotalQuantity(updatedTotalQuantity)를 호출하여 totalQuantity 상태 값을 업데이트한다.

	- setTotalPrice(updatedTotalPrice)를 호출하여 totalPrice 상태 값을 업데이트한다.

	- 이를 통해 countHandle 함수는 리워드의 개수를 처리하고, 개수와 가격의 변화에 따라 rewards, totalQuantity, totalPrice 값을 업데이트한다.

- increaseCount
	- newRewards[rewardIndex].fundingReward.count 값을 1 증가시킨다.

	- rewardPrice 변수는 리워드의 가격을 나타낸다.

	- priceIncrease 변수는 각 개수 증가에 따라 증가되어야 할 가격을 계산한다. 즉, 리워드의 가격을 개수에서 1을 뺀 값으로 나눈 것이다.

	- newRewards[rewardIndex].fundingReward.rewardPrice에 priceIncrease를 더하여 리워드의 가격을 업데이트한다.

	- setTotalQuantity(quantity => quantity + 1)를 호출하여 totalQuantity 상태 값을 1 증가시킨다.

	- setTotalPrice(price => price + priceIncrease)를 호출하여 totalPrice 상태 값을 priceIncrease만큼 증가시킨다.

	- setRewards(newRewards)를 호출하여 rewards 상태 값을 업데이트한다.

	- 이를 통해 increaseCount 함수는 보상의 개수를 1 증가시키고, 개수에 따라 가격을 조정하여 rewards, totalQuantity, totalPrice 값을 업데이트한다.

---

</br></br>

## BackEnd

**Controller**

- 펀딩 상세 페이지에 필요한 것들

```java

@RestController
@RequiredArgsConstructor
@RequestMapping("/fundingdetail")
public class FundingDetailController {
	
	private final FundingDetailService fundingDetailService;

	@GetMapping("/{pageId}")
	public ResponseEntity<?> fundingDetail(@PathVariable int pageId) {
		
		return ResponseEntity.ok(fundingDetailService.fundingDetail(pageId));
	}
	
	@GetMapping("/reward/{pageId}")
	public ResponseEntity<?> fundingReward(@PathVariable int pageId) {
		
		return ResponseEntity.ok(fundingDetailService.getReward(pageId));
	}
	
	@GetMapping("/businessinfo/{pageId}")
	public ResponseEntity<?> fundingBusinessInfo(@PathVariable int pageId) {
		
		return ResponseEntity.ok(fundingDetailService.getBusinessInfo(pageId));
	}
	
	@GetMapping("/breakdown/{pageId}")
	public ResponseEntity<?> breakdown(@PathVariable int pageId) {
		
		return ResponseEntity.ok(fundingDetailService.getBreakdown(pageId));
	}
	
	@GetMapping("/address")
	public ResponseEntity<?> getAddress(@RequestParam int userId) {
		return ResponseEntity.ok(fundingDetailService.getAddressId(userId));
	}
	
}

```

</br>

```java

@RestController
@RequiredArgsConstructor
public class AccountController {

	private final AccountService accountService;
	
	@GetMapping("/principal")
	public ResponseEntity<?> principal() {
		return ResponseEntity.ok().body(accountService.getPrincipal());
	}
	
}

```

</br>

- 펀딩 상세페이지에 필요한 데이터인 기본 정보들을 들고오려고 한다.

- 결제를 위해 유저에 대한 정보를 들고오려고 한다.

---

</br></br>

**Service**

- 펀딩 상세 페이지에 쓸 정보

```java

@Service
@RequiredArgsConstructor
public class FundingDetailService {

	private final FundingDetailRepository fundingDetailRepository;
	
	public FundingDetailRespDto fundingDetail(int pageId) {
		return fundingDetailRepository.fundingDetail(pageId).getDetailFunding();
	}
	
	public Map<String, Object> getReward(int pageId) {
		List<RewardRespDto> rewardList = new ArrayList<>();
		
		fundingDetailRepository.getReward(pageId).forEach(reward -> {
			rewardList.add(reward.getFundingReward());
		});
		
		Map<String, Object> rewardMap = new HashMap<>();
		rewardMap.put("rewardList", rewardList);
		
		return rewardMap;
	}
	
	public BusinessInfoRespDto getBusinessInfo(int pageId) {
		return fundingDetailRepository.getBusinessInfo(pageId).toBusinessInfo();
	}
	
	public Map<String, Object> getBreakdown(int pageId) {
		List<BreakdownRespDto> breakdownList = new ArrayList<>();
		fundingDetailRepository.getBreakdown(pageId).forEach(breakdown -> {
			breakdownList.add(breakdown.toBreakdown());
		});
		
		Map<String, Object> breakdownMap = new HashMap<>();
		breakdownMap.put("breakdownList", breakdownList);
		
		return breakdownMap;
	}
	
	public Address getAddressId(int userId) {
		return fundingDetailRepository.getAddressId(userId);
	}
	
}

```

</br>

- 로그인한 유저가 맞는지 확인

```java

@Service
@RequiredArgsConstructor
public class AccountService {

	private final UserRepository signUpRepository;

	public PrincipalRespDto getPrincipal() {
		PrincipalUserDetails principalUserDetails = (PrincipalUserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		User userEntity = signUpRepository.findUserByEmail(principalUserDetails.getEmail());
		StringBuilder roles = new StringBuilder();
		principalUserDetails.getAuthorities().forEach(authority -> {
			roles.append(authority.getAuthority() + ",");
		});
		roles.delete(roles.length() - 1, roles.length());
		
		return PrincipalRespDto.builder()
				.userId(userEntity.getUserId())
				.email(userEntity.getEmail())
				.name(userEntity.getName())
				.authorities(roles.toString())
				.phoneNumber(userEntity.getPhoneNumber())
				.build();
	}
	
}

```

</br>

- FundingDetailService에서는 여태 써왔던 방식대로 Map에다가 데이터를 받아서 반환을 한다.

- 요청 받은 token에 대한 인증을 하기 위해 값을 넘겨준다.

- 유저 정보에 대한 확인을 위한 검사 과정

- db에 있는 email과 요청으로 받은 token을 열어서 그 email이 일치한지 알아본다.

---

</br></br>

**Dto**

- 펀딩 상세 페이지 상단에 들어가는 기본 정보

```java

@Builder
@Data
public class FundingDetailRespDto {
	private int fundingId;
	private String fundingSummaryName;
	private String fundingTitle;
	private String deadline;
	private int goalTotal;
	private int totalRewardPrice;
	private String storyTitle;
	private String storyContent;
	private String mainImgUrl;
	private String subImgUrl;
	private int joinPercent;
}

```

</br>

- 리워드 관련된 정보

```java

@Data
@Builder
public class RewardRespDto {
	private int rewardId;
	private String rewardName;
	private int rewardPrice;
	private int fundingId;
	private LocalDate endDate;
	private String userCount;
}

```

</br>

- 사업자 정보

```java

@Builder
@Data
public class BusinessInfoRespDto {
	private int businessInfoId;
	private String companyName;
	private String ceoName;
	private String companyAddress;
	private String companyPhoneNumber;
	private String ceoEmail;
	private int fundingId;
}

```

</br>

- 참여내역

```java

@Data
@Builder
public class BreakdownRespDto {
	private int fundingId;
	private int userId;
	private String username;
	private int totalRewardPrice;
}

```

</br>

- 각기 필요한 정보를 반환할 객체들이다. 

---

</br></br>

**Entity**

- 펀딩 상세 페이지 상단에 들어가는 기본 정보

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Funding {
	private int fundingId;
	private int userId;
	private String fundingTitle;
	private LocalDate endDate;
	private String fundingSummaryName;
	private String username;
	private int recentSort;
	private String nearDeadline;
	private String eventStatus;
	private int goalTotal;
	private int totalRewardPrice;
	private int joinPercent;
	private String mainImgUrl;
	private String subImgUrl;
	private int fundingCategoryId;
	private String storyTitle;
	private String storyContent;

	public FundingDetailRespDto getDetailFunding() {
		return FundingDetailRespDto.builder()
				.fundingId(fundingId)
				.fundingSummaryName(fundingSummaryName)
				.fundingTitle(fundingTitle)
				.deadline(nearDeadline)
				.goalTotal(goalTotal)
				.totalRewardPrice(totalRewardPrice)
				.storyTitle(storyTitle)
				.storyContent(storyContent)
				.mainImgUrl(mainImgUrl)
				.subImgUrl(subImgUrl)
				.joinPercent(joinPercent)
				.build();
	}
}

```

</br>

- 리워드 관련된 정보

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Reward {
	private String pageCategory;
	private int rewardId;
	private String rewardName;
	private int rewardPrice;
	private int fundingId;
	private LocalDate endDate;
	private String userCount;
	
	public RewardRespDto getFundingReward() {
		return RewardRespDto.builder()
				.rewardId(rewardId)
				.rewardName(rewardName)
				.rewardPrice(rewardPrice)
				.fundingId(fundingId)
				.endDate(endDate)
				.userCount(userCount)
				.build();
	}
}

```

</br>

- 사업자 정보

```java

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BusinessInfo {
	private String pageCategory;
	private int businessInfoId;
	private String companyName;
	private String ceoName;
	private String companyAddress;
	private String companyPhoneNumber;
	private String ceoEmail;
	private int fundingId;
	
	public BusinessInfoRespDto toBusinessInfo() {
		return BusinessInfoRespDto.builder()
				.businessInfoId(businessInfoId)
				.companyName(companyName)
				.ceoName(ceoName)
				.companyAddress(companyAddress)
				.companyPhoneNumber(companyPhoneNumber)
				.ceoEmail(ceoEmail)
				.fundingId(fundingId)
				.build();
	}
}

```

</br>

- 참여내역

```java

@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Funding {
	private int fundingId;
	private int userId;
	private String fundingTitle;
	private LocalDate endDate;
	private String fundingSummaryName;
	private String username;
	private int recentSort;
	private String nearDeadline;
	private String eventStatus;
	private int goalTotal;
	private int totalRewardPrice;
	private int joinPercent;
	private String mainImgUrl;
	private String subImgUrl;
	private int fundingCategoryId;
	private String storyTitle;
	private String storyContent;

	public BreakdownRespDto toBreakdown() {
		return BreakdownRespDto.builder()
				.fundingId(fundingId)
				.userId(userId)
				.username(username)
				.totalRewardPrice(totalRewardPrice)
				.build();
	}

}

```

</br>

- sql에서 받은 데이터들을 RespDto로 반환해주고 있다.

---

</br></br>

**Repository**

```java

@Mapper
public interface FundingDetailRepository {
	public Funding fundingDetail(int pageId);
	public List<Reward> getReward(int pageId);
	public BusinessInfo getBusinessInfo(int pageId);
	public List<Funding> getBreakdown(int pageId);
	public Address getAddressId(int userId);
}

```

</br>

- pageId(내가 클릭한 펀딩)로 sql에서 특정 펀딩을 찾아 데이터를 들고올 것이다. 

- userId는 위에서 로그인 확인이 끝난 유저의 번호다. 그 번호로 유저의 주소를 들고올 것임.

---

</br></br>

**Sql**

- 펀딩 상세 페이지 상단에 들어가는 기본 정보

```sql

	<resultMap type="com.webproject.crowdfunding.entity.Funding" id="FundingDetailMap">
		<id property="fundingId" column="funding_id"/>
		<result property="userId" column="user_id"/>
		<result property="fundingSummaryName" column="funding_summary_name"/>
		<result property="fundingTitle" column="funding_title"/>
		<result property="username" column="username"/>
		<result property="nearDeadline" column="deadline"/>
		<result property="goalTotal" column="goal_total"/>
		<result property="totalRewardPrice" column="total_reward_price"/>
		<result property="storyTitle" column="story_title"/>
		<result property="storyContent" column="story_content"/>
		<result property="mainImgUrl" column="main_img_url"/>
		<result property="subImgUrl" column="sub_img_url"/>
		<result property="joinPercent" column="join_percent"/>
	</resultMap>

	<select id="fundingDetail" resultMap="FundingDetailMap" parameterType="integer">
		select
		    fpt.funding_id,
		    fpt.funding_summary_name,
		    fpt.funding_name as funding_title,
		    CONCAT(
		    IF(NOW() &lt; fpt.end_date,  DATEDIFF(fpt.end_date, NOW()), IF(DATEDIFF(NOW(), fpt.end_date) = 0, '오늘 마감', '종료'))
		    ) as deadline,
		    fpt.goal_total,
		    sum(if(ft.funder_id is null, 0, rt.reward_price)) as total_reward_price,
		    fpt.story_title,
		    fpt.story_content,
		    fpt.main_img_url as main_img_url,
		    fpsit.img_url as sub_img_url,
		    ROUND((sum(if(ft.funder_id is null, 0, rt.reward_price)) / fpt.goal_total) * 100) as join_percent
		from
		    funding_page_tb fpt
		    left outer join reward_tb rt on (rt.funding_id = fpt.funding_id)
		    left outer join funder_tb ft on (ft.reward_id = rt.reward_id)
		    left outer join funding_page_sub_img_tb fpsit on (fpsit.funding_id = fpt.funding_id)
		where
		    fpt.funding_id = #{pageId};
	</select>

```

</br>

- 리워드 관련된 정보

```sql

	<resultMap type="com.webproject.crowdfunding.entity.Reward" id="RewardMap">
		<id property="rewardId" column="reward_id"/>
		<result property="fundingId" column="funding_id"/>
		<result property="rewardName" column="reward_name"/>
		<result property="rewardPrice" column="reward_price"/>
		<result property="endDate" column="end_date"/>
		<result property="userCount" column="user_count"/>
	</resultMap>

	<select id="getReward" parameterType="integer" resultMap="RewardMap">
		select
		    rt.reward_id,
		    rt.funding_id,
		    rt.reward_name,
		    rt.reward_price,
		    fpt.end_date,
		    count(distinct ut.user_id) as user_count
		from 
	            reward_tb rt
		    left outer join funding_page_tb fpt on(fpt.funding_id = rt.funding_id)
		    left outer join funder_tb ft on(ft.reward_id = rt.reward_id)
		    left outer join user_tb ut on(ut.user_id = ft.user_id)
		where
		    rt.funding_id = #{pageId}
		group by
		    reward_id;
	</select>

```

</br>

- 사업자 정보

```sql

	<resultMap type="com.webproject.crowdfunding.entity.BusinessInfo" id="BusinessInfoMap">
		<id property="businessInfoId" column="business_info_id"/>
		<result property="companyName" column="company_name"/>
		<result property="ceoName" column="ceo_name"/>
		<result property="companyAddress" column="company_address"/>
		<result property="companyPhoneNumber" column="company_phone_number"/>
		<result property="ceoEmail" column="ceo_email"/>
		<result property="fundingId" column="funding_id"/>
	</resultMap>

	<select id="getBusinessInfo" parameterType="integer" resultMap="BusinessInfoMap">
		select
		    bt.business_info_id,
		    bt.company_name,
		    bt.ceo_name,
		    bt.company_address,
		    bt.company_phone_number,
		    bt.ceo_email,
		    bt.funding_id
		from
		    business_info_tb bt
		where
		    bt.funding_id = #{pageId};
	</select>

```

</br>

- 참여내역

```sql

	<select id="getBreakdown" parameterType="integer" resultMap="FundingDetailMap">
		select
		    fpt.funding_id,
		    ut.user_id,
		    ut.name as username,
		    sum(if(ft.funder_id is null, 0, rt.reward_price)) as total_reward_price
		from
		    funding_page_tb fpt
		    left outer join reward_tb rt on(rt.funding_id = fpt.funding_id)
		    left outer join funder_tb ft on(ft.reward_id = rt.reward_id)
		    left outer join user_tb ut on(ut.user_id = ft.user_id)
		where
		    fpt.funding_id = #{pageId}
		    AND ut.user_id IS NOT NULL
		    AND ut.name IS NOT NULL
		group by
		    funding_id,
		    user_id,
		    username
	</select>

```

</br>

- 주소 정보

```sql

	<resultMap type="com.webproject.crowdfunding.entity.Address" id="AddressMap">
		<id property="addressId" column="address_id"/>
		<result property="userId" column="user_id"/>
		<result property="zonecode" column="zonecode"/>
		<result property="address" column="address"/>
		<result property="buildingName" column="building_name"/>
		<result property="bname" column="bname"/>
		<result property="detailAddress" column="detail_address"/>
		<result property="addressType" column="address_type"/>
	</resultMap>

	<select id="getAddressId" parameterType="integer" resultMap="AddressMap">
		select
			at.address_id,
			at.user_id,
			at.zonecode,
			at.address,
			at.building_name,
			at.bname,
			at.detail_address,
			at.address_type
		from
			address_tb at
		where
			at.user_id = #{userId};
	</select>

```

</br>

- 형식은 펀딩 메인 페이지 코드 리뷰에서 한 것과 동일하다. 각 테이블에서 필요한 것들을 join하고, 필요에 맞게 이름을 바꿔주었다.

- 이 정보들을 각 Entity에 맞게 값을 반환해주고 있다.

---

</br></br>

**Database**

- 펀딩 상세 페이지 상단 정보

![펀딩 상세 페이지 상단](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/8b2fe954-9373-45f4-98d2-ec9644bcb9f4)

</br>

- 리워드 관련 정보

![리워드 관련 정보](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/d3ce8b99-2f61-44bb-92c1-dcd74f51312d)

</br>

- 사업자 정보

![사업자 정보](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/ea82184e-8e52-46f3-8687-eda044f1a220)

</br>

- 참여내역

![참여내역2](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/5653092f-0cb8-463d-a71b-d7455bf3cdbc)

</br>

- 주소 정보

![주소 정보](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/4dbc05f2-c7a1-4cc0-9624-fb0344e4800c)

</div>
</details>

<br/>

### **관리자 펀딩 및 기부 등록 페이지 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 및 펀딩 등록 유효성 검사 영상 및 코드 리뷰</summary>
<div markdown="1">

</br>

**영상**

</br>

![관리자 페이지 유효성 검사 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/d5d256ce-e970-40a9-9496-9aa57a43197f)

</br></br>

## FrontEnd

**요청**

- 기부

```javascript

    const giveRegisterPage = async () => {
        const formData = new FormData();
        formData.append("pageCategory", giveInputParams.pageCategory);
        formData.append("detailCategory", giveInputParams.detailCategory)
        formData.append("title", giveInputParams.title)
        formData.append("storyTitle", giveInputParams.storyTitle)
        formData.append("story", giveInputParams.story)
        mainImgFiles.forEach(imgFile => {
            formData.append("mainImgUrl", imgFile.file);
        })
        subImgFiles.forEach(imgFile => {
            formData.append("subImgUrl", imgFile.file);
        })
        formData.append("goalTotal", giveInputParams.goalTotal);
        formData.append("endDate", giveInputParams.endDate);
        formData.append("giveUsing", giveInputParams.giveUsing);
        formData.append("donationExpense", giveInputParams.donationExpense);
        formData.append("businessStartDate", giveInputParams.businessStartDate);
        formData.append("businessEndDate", giveInputParams.businessEndDate);
        formData.append("target", giveInputParams.target);
        formData.append("targetCount", giveInputParams.targetCount);
        formData.append("benefitEffect", giveInputParams.benefitEffect);
        formData.append("companyName", giveInputParams.companyName)
        formData.append("ceoName", giveInputParams.ceoName)
        formData.append("companyAddress", giveInputParams.companyAddress)
        formData.append("companyPhoneNumber", giveInputParams.companyPhoneNumber)

        const option = {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        }
        try {
            await axios.post("http://localhost:8080/admin/giving/registerpage", formData, option)
            alert("기부 페이지 등록 성공");
            navigate("/giving");
        } catch (error) {
            giveFundErrorMessages({
                title: "",
                storyTitle: "",
                story: "",
                mainImgUrl: "",
                subImgUrl: "",
                endDate: "",
                giveUsing: "",
                businessStartDate: "",
                businessEndDate: "",
                target: "",
                benefitEffect: "",
                companyName: "",
                ceoName: "",
                companyAddress: "",
                companyPhoneNumber: "",
                ...error.response.data.errorData})
        }
    };

```

</br>

- 펀딩

```javascript

    const fundingRegisterPage = async () => {
        const formData = new FormData();
        formData.append("pageCategory", fundingInputParams.pageCategory);
        formData.append("detailCategory", fundingInputParams.detailCategory)
        formData.append("title", fundingInputParams.title)
        formData.append("storyTitle", fundingInputParams.storyTitle)
        formData.append("story", fundingInputParams.story)
        mainImgFiles.forEach(imgFile => {
            formData.append("mainImgUrl", imgFile.file);
        })
        subImgFiles.forEach(imgFile => {
            formData.append("subImgUrl", imgFile.file);
        })
        formData.append("goalTotal", fundingInputParams.goalTotal);
        formData.append("endDate", fundingInputParams.endDate);
        formData.append("rewardName", fundingInputParams.rewardName)
        formData.append("rewardPrice", fundingInputParams.rewardPrice)
        formData.append("companyName", fundingInputParams.companyName)
        formData.append("ceoName", fundingInputParams.ceoName)
        formData.append("nickname", fundingInputParams.nickname)
        formData.append("companyAddress", fundingInputParams.companyAddress)
        formData.append("companyPhoneNumber", fundingInputParams.companyPhoneNumber)
        formData.append("email", fundingInputParams.email)
        const option = {
            headers: {
                "Content-Type": "multipart/form-data",
                Authorization: `Bearer ${accessToken}`
            }
        }
        try {
            await axios.post("http://localhost:8080/admin/funding/registerpage", formData, option);
            alert("펀딩 페이지 등록 성공");
            navigate("/funding");
        } catch (error) {
            setFundErrorMessages({
                title: "",
                storyTitle: "",
                story: "",
                mainImgUrl: "",
                subImgUrl: "",
                endDate: "",
                rewardName: "",
                companyName: "",
                ceoName: "",
                nickname: "",
                companyAddress: "",
                companyPhoneNumber: "",
                email:""
                , ...error.response.data.errorData})
        }
    };

```

</br>

- 요청을 보내고 에러가 있을 경우 오는 메세지를 담고 있다. 

---

</br></br>

## BackEnd

**Dto**

- 기부

```java

@Data
public class GivingRegisterReqDto {
	private String pageCategory;
	private String detailCategory;
	@NotBlank(message= "제목을 입력해주세요.")
	private String title;
	
	@NotBlank(message= "스토리 제목을 입력해주세요.")
	private String storyTitle;
	
	@NotBlank(message= "스토리 내용을 입력해주세요.")
	private String story;
	
	@NotNull(message= "메인 이미지를 첨부해주세요.")
	private MultipartFile mainImgUrl;
	
	@NotNull(message= "상세 이미지를 첨부해주세요.")
	private MultipartFile subImgUrl;
	
	private int goalTotal;
	
	@NotBlank(message= "종료 날짜를 입력해주세요.")
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
            	message = "종료 날짜를 형식에 맞게 작성해주세요.")
	private String endDate;
    
	@NotEmpty(message= "기부금 사용 계획은 한 개 이상이어야 합니다.")
	private List<
	@NotBlank(message= "기부금 사용 내역을 입력해주세요.")
	String> giveUsing;
	
	private List<Integer> donationExpense;
	
	@NotBlank(message= "사업 시작 날짜를 입력해주세요.")
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
           	 message = "사업 시작 날짜를 형식에 맞게 작성해주세요.")
	private String businessStartDate;
    
	@NotBlank(message= "사업 종료 날짜를 입력해주세요.")
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
    	message = "사업 종료 날짜를 형식에 맞게 작성해주세요.")
	private String businessEndDate;
    
    	@NotBlank(message= "대상을 입력해주세요.")
	private String target;
    
	private int targetCount;
    
    	@NotBlank(message= "사업 효과를 입력해주세요.")
	private String benefitEffect;
    
    	@NotBlank(message= "단체명을 입력해주세요.")
	private String companyName;
    
    	@NotBlank(message= "대표명을 입력해주세요.")
	private String ceoName;
    
    	@NotBlank(message= "사업자 주소를 입력해주세요.")
	private String companyAddress;
    
    	@NotBlank(message= "고객센터 전화번호를 입력해주세요.")
	private String companyPhoneNumber;
}

```

</br>

- 펀딩 

```java

@Data
public class FundingRegisterPageReqDto {
	private String pageCategory;
	private String detailCategory;
	@NotBlank(message= "제목을 입력해주세요.")
	private String title;
	
	@NotBlank(message= "스토리 제목을 입력해주세요.")
	private String storyTitle;
	
	@NotBlank(message= "스토리 내용을 입력해주세요.")
	private String story;
	
	@NotNull(message= "메인 이미지를 첨부해주세요.")
	private MultipartFile mainImgUrl;
	
	@NotNull(message= "상세 이미지를 첨부해주세요.")
	private MultipartFile subImgUrl;
	
	private int goalTotal;
	
	@NotBlank(message= "종료 날짜를 입력해주세요.")
    	@Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$",
            	message = "종료 날짜를 형식에 맞게 작성해주세요.")
	private String endDate;
    
    	@NotEmpty(message= "리워드는 한 개 이상이어야 합니다.")
    	private List<
    	@NotBlank(message= "리워드를 입력해주세요.")
    	String> rewardName;
    
	private List<Integer> rewardPrice;
    
    	@NotBlank(message= "상호명을 입력해주세요.")
	private String companyName;
    
    	@NotBlank(message= "대표명을 입력해주세요.")
	private String ceoName;
    
	@NotBlank(message= "닉네임을 입력해주세요.")
	private String nickname;
    
    	@NotBlank(message= "사업자 주소를 입력해주세요.")
	private String companyAddress;
    
    	@NotBlank(message= "고객센터 전화번호를 입력해주세요.")
	private String companyPhoneNumber;
    
    	@NotBlank(message= "이메일을 입력해주세요.")
    	@Email
	private String email;

```

- Controller로 넘어오면서 유효성 검사를 하는 부분. 해당되는 부분에 에러메세지를 반환한다.

---

</div>
</details>

<details>
<summary>기부 등록 영상</summary>
<div markdown="1">

![기부 등록 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/311a9a48-11e9-44a9-8691-0def0355ba07)

</div>
</details>

<details>
<summary>펀딩 등록 영상</summary>
<div markdown="1">

![펀딩 등록 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/69890336-542c-42f2-b6fd-43ee0dbd6f89)

</div>
</details>

<details>
<summary>펀딩 & 기부 등록 코드 리뷰 - 파일 입출력 포함</summary>
<div markdown="1">

## FrontEnd

**기부 & 펀딩 등록 html 코드**

- 기부

```html

{giveInputParams.pageCategory === '기부' ? 
            <>
                <div css={mainTitleContainer}>
                    <h1 css={mainTitle}>기부 페이지 등록</h1>
                </div>
                <div css={infoInputContainer}>
                    <div css={subTitle}>
                        기부 카테고리 설정
                    </div>
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 페이지 카테고리</div>
                        <div css={inputContainer}>
                        <select onChange={changeGivePageCategory} css={comboBox}>
                            {mainCategoryList.map((item) => (
                                <option value={item} key={item}>
                                    {item}
                                </option>
                                ))}
                        </select> 
                        </div> 
                    </div>
                </div>
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 상세 카테고리</div>
                        <div css={inputContainer}>
                            {giveInputParams.pageCategory === '기부' ? 
                        <select onChange={changeDetailCategory} css={comboBox}>
                            {giveSubCategoryList.map((item) => (
                                <option value={item} key={item}>
                                    {item}
                                </option>
                                ))}
                                </select> :<select onChange={changeDetailCategory} css={comboBox}>
                            {fundSubCateogoryList.map((item) => (
                                <option value={item} key={item}>
                                    {item}
                                </option>
                            ))}
                            </select>}
                        </div> 
                    </div>
                    <div css={subTitle}>
                        기부 페이지 설정
                    </div>
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 제목</div>
                        <div css={inputContainer}>
                            <input onChange={changeTitle} css={input} type="text"/>
                            <div css={errorMsg}>{giveErrorMessages.title}</div>
                        </div> 
                    </div>
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 스토리 제목</div>
                        <div css={inputContainer}>
                            <input onChange={changeStoryTitle} css={input} type="text"/>
                            <div css={errorMsg}>{giveErrorMessages.storyTitle}</div>  
                        </div> 
                    </div>
                    <div css={storyInfoInput}>
                        <div css={storyInfoTitle}>기부 스토리 내용</div>
                        <div css={storyInputContainer}>
                        <textarea onChange={changeStory} css={storyTextArea} name="" id="" cols="30" rows="10"></textarea>
                        <div css={errorMsg}>{giveErrorMessages.story}</div> 
                        </div> 
                    </div>
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 메인 이미지</div>
                        <div css={inputContainer}>
                            <input css={input} type="file" onChange={changeMainImgUrl} accept={".jpg, .png"}/>
                            <div css={errorMsg}>{giveErrorMessages.mainImgUrl}</div>   
                        </div> 
                    </div>

                    <div css={infoInput}>
                        <div css={infoTitle}>기부 스토리 이미지</div>
                        <div css={inputContainer}>
                            <input css={input} type="file" onChange={changeSubImgUrl} accept={".jpg, .png"}/>
                            <div css={errorMsg}>{giveErrorMessages.subImgUrl}</div>  
                        </div> 
                    </div>
                
                    <div css={infoInput}>
                        <div css={infoTitle}>기부 목표 금액</div>
                        <div css={inputContainer}>
                            <input onChange={changeGoalTotal} css={input} type="text"/>원    
                        </div> 
                    </div>

                    <div css={infoInput}>
                        <div css={infoTitle}>기부 종료일</div>
                        <div css={inputContainer}>
                            <input onChange={changeEndDate} css={input} type="text"/>
                            <div css={errorMsg}>{giveErrorMessages.endDate}</div>   
                        </div> 
                    </div>
                    {showTable && giveInputParams.pageCategory === '기부' ?
                    <div css={rewardInfoInputContainer}>
                        <div css={rewardHeader}>
                            <h1 css={rewardH1}>기부금 사용 계획</h1>
                            <div css={btnContainer}>
                                <button css={rewardBtn} onClick={addGiveUsingInputComponentHandle}>+</button>
                            </div>
                        </div>
                        <table css={rewardTable}>
                            <thead>
                                <tr css={rewardTr}>
                                    <th css={rewardNameThAndTd}>사용 내역</th>
                                    <th css={rewardPriceThAndTd}>사용 금액</th>
                                </tr>
                            </thead>
                            <tbody>
                                {giveTds.map(giveTd => (
                                    <tr css={rewardTr} key={giveTd.id}>
                                        <td css={rewardNameThAndTd}><input onChange={(e)=> handleGivingUsingChange(giveTd.id,e)} css={rewardTdInput} type="text"/></td>
                                        <td css={rewardPriceThAndTd}><input onChange={(e)=> handleGivingUsingPriceChange(giveTd.id,e)} css={rewardTdInput} type="number" placeholder='(원)'/><button css={rewardBtn} value={giveTd.id} onClick={(e)=>removeGiveUsingInputComponentHandle(giveTd.id,e)}>-</button></td>    
                                    </tr>
                                ))}
                                <div css={rewardMsg}>{giveErrorMessages.giveUsing}</div>
                            </tbody>
                        </table>
                        <div css={saveBtnContainer}>
                            <button onClick={madeGiveUsingList}>저장하기</button>
                        </div>
                    </div>
                : ""}
                <div css={subTitle}>
                    사업대상 및 기대효과
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>사업 시작일</div>
                    <div css={inputContainer}>
                        <input onChange={changeBusinessStartDate} css={input} type="text"/>
                        <div css={errorMsg}>{giveErrorMessages.businessStartDate}</div>
                    </div> 
                </div> 
                <div css={infoInput}>
                    <div css={infoTitle}>사업 종료일</div>
                    <div css={inputContainer}>
                        <input onChange={changeBusinessEndDate} css={input} type="text"/>
                        <div css={errorMsg}>{giveErrorMessages.businessEndDate}</div>
                    </div> 
                </div> 
                <div css={infoInput}>
                    <div css={infoTitle}>사업 대상</div>
                    <div css={inputContainer}>
                        <input onChange={changeTarget} css={input} type="text"/> 
                        <div css={errorMsg}>{giveErrorMessages.target}</div>   
                    </div> 
                </div> 
                <div css={infoInput}>
                    <div css={infoTitle}>대상 수</div>
                    <div css={inputContainer}>
                        <input onChange={changeTargetCount} css={input} type="text"/>    
                    </div> 
                </div> 
                <div css={infoInput}>
                    <div css={infoTitle}>기대 효과</div>
                    <div css={inputContainer}>
                        <input onChange={changeBenefitEffect} css={input} type="text"/>
                        <div css={errorMsg}>{giveErrorMessages.benefitEffect}</div> 
                    </div> 
                </div>
                <div css={subTitle}>
                    기부 신청인 등록
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>단체명</div>
                    <div css={inputContainer}>
                        <input onChange={changeCompanyName} css={input} type="text"/>
                        <div css={errorMsg}>{giveErrorMessages.companyName}</div> 
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>대표자</div>
                    <div css={inputContainer}>
                        <input onChange={changeCeoName} css={input} type="text"/>
                        <div css={errorMsg}>{giveErrorMessages.ceoName}</div>
                    </div> 
                </div> 
                <div css={infoInput}>
                    <div css={infoTitle}>주소</div>
                    <div css={inputContainer}>
                        <input onChange={changeCompanyAddress} css={input} type="text"/>    
                        <div css={errorMsg}>{giveErrorMessages.companyAddress}</div>
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>고객센터</div>
                    <div css={inputContainer}>
                        <input onChange={changePhoneNumber} css={input} type="text"/>    
                        <div css={errorMsg}>{giveErrorMessages.companyPhoneNumber}</div>
                    </div> 
                </div>
            <div css={submitBtnContainer}>
                <button onClick={giveRegisterPage}>기부 페이지 등록하기</button>
            </div>

```

</br>

- 펀딩

```html
        </> :          
        <>
            <div css={mainTitleContainer}>
                <h1 css={mainTitle}>펀딩 페이지 등록</h1>
            </div>
            <div css={infoInputContainer}>
                <div css={subTitle}>
                    펀딩 카테고리 설정
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 페이지 카테고리</div>
                    <div css={inputContainer}>
                    <select onChange={changeFundingPageCategory} css={comboBox}>
                        {mainCategoryList.map((item) => (
                            <option value={item} key={item}>
                                {item}
                            </option>
                            ))}
                            </select> 
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 상세 카테고리</div>
                    <div css={inputContainer}>
                    {fundingInputParams.pageCategory === '펀딩' ? 
                    <select onChange={changeDetailCategory} css={comboBox}>
                        {fundSubCateogoryList.map((item) => (
                            <option value={item} key={item}>
                                {item}
                            </option>
                            ))}
                            </select> :<select onChange={changeDetailCategory} css={comboBox}>
                        {giveSubCategoryList.map((item) => (
                            <option value={item} key={item}>
                                {item}
                            </option>
                            ))}
                            </select>}
                    </div> 
                </div>
                <div css={subTitle}>
                    펀딩 페이지 설정
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 제목</div>
                    <div css={inputContainer}>
                        <input onChange={changeTitle} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.title}</div>  
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 스토리 제목</div>
                    <div css={inputContainer}>
                        <input onChange={changeStoryTitle} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.storyTitle}</div>
                    </div> 
                </div>
                <div css={storyInfoInput}>
                    <div css={storyInfoTitle}>펀딩 스토리 내용</div>
                    <div css={storyInputContainer}>
                    <textarea onChange={changeStory} css={storyTextArea} name="" id="" cols="30" rows="10"></textarea>
                    <div css={errorMsg}>{fundErrorMessages.story}</div> 
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 메인 이미지</div>
                    <div css={inputContainer}>
                    <input css={input} type="file" onChange={changeMainImgUrl} accept={".jpg, .png"}/>
                    <div css={errorMsg}>{fundErrorMessages.mainImgUrl}</div>    
                    </div> 
                </div>

                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 스토리 이미지</div>
                    <div css={inputContainer}>
                    <input css={input} type="file" onChange={changeSubImgUrl} accept={".jpg, .png"}/>
                    <div css={errorMsg}>{fundErrorMessages.subImgUrl}</div>
                    </div> 
                </div>
            
                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 목표 금액</div>
                    <div css={inputContainer}>
                        <input onChange={changeGoalTotal} css={input} type="text" placeholder='숫자만 입력해주세요'/>원 
                    </div> 
                </div>

                <div css={infoInput}>
                    <div css={infoTitle}>펀딩 종료일</div>
                    <div css={inputContainer}>
                        <input onChange={changeEndDate} css={input} type="text" placeholder='예) 2000-05-10'/>
                        <div css={errorMsg}>{fundErrorMessages.endDate}</div>
                    </div> 
                </div>
                {showTable && fundingInputParams.pageCategory === '펀딩' ? 
                    <div css={rewardInfoInputContainer}>
                        <div css={rewardHeader}>
                            <h1 css={rewardH1}>리워드 추가</h1>
                            <div css={btnContainer}>
                                <button css={rewardBtn} onClick={addRewardInputComponentHandle}>+</button>
                            </div>
                        </div>
                        <table css={rewardTable}>
                            <thead>
                                <tr css={rewardTr}>
                                    <th css={rewardNameThAndTd}>리워드</th>
                                    <th css={rewardPriceThAndTd}>금액</th>
                                </tr>
                            </thead>
                            <tbody>
                                {rewardTds.map(rewardTd => (
                                    <tr css={rewardTr} key={rewardTd.id}>
                                        <td css={rewardNameThAndTd}><input onChange={(e)=> handleRewardNameChange(rewardTd.id,e)} css={rewardTdInput} type="text"/></td>
                                        <td css={rewardPriceThAndTd}><input onChange={(e)=> handleRewardPriceChange(rewardTd.id,e)} css={rewardTdInput} type="number" placeholder='(원)'/><button css={rewardBtn} value={rewardTd.id} onClick={(e)=>removeRewardInputComponentHandle(rewardTd.id,e)}>-</button></td>    
                                    </tr>
                                ))}
                                <div css={rewardMsg}>{fundErrorMessages.rewardName}</div>
                            </tbody>
                        </table>
                        <div css={saveBtnContainer}>
                            <button onClick={madeRewardList}>저장하기</button>
                        </div>
                    </div>
                : ""}
                <div css={subTitle}>
                    펀딩 신청인 등록
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>상호명</div>
                    <div css={inputContainer}>
                        <input onChange={changeCompanyName} css={input} type="text"/>    
                        <div css={errorMsg}>{fundErrorMessages.companyName}</div>
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>대표자</div>
                    <div css={inputContainer}>
                        <input onChange={changeCeoName} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.ceoName}</div> 
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>닉네임</div>
                    <div css={inputContainer}>
                        <input onChange={changeNickname} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.nickname}</div>  
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>주소</div>
                    <div css={inputContainer}>
                        <input onChange={changeCompanyAddress} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.companyAddress}</div>
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>고객센터</div>
                    <div css={inputContainer}>
                        <input onChange={changePhoneNumber} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.companyPhoneNumber}</div>
                    </div> 
                </div>
                <div css={infoInput}>
                    <div css={infoTitle}>이메일</div>
                    <div css={inputContainer}>
                        <input onChange={changeEmail} css={input} type="text"/>
                        <div css={errorMsg}>{fundErrorMessages.email}</div>  
                    </div> 
                </div>
            </div>
            <div css={submitBtnContainer}>
                <button onClick={fundingRegisterPage}>펀딩 페이지 등록하기</button>
            </div>
        </>}

```

</br>

- 웹 페이지에서 input 창에 값을 써주고 그 값들을 onChange 속성으로 넘겨준다.

---

</br></br>

**입력 받은 값 처리**

```javascript

    const [ mainImgFiles, setMainImgFiles ] = useState([]);
    const [ subImgFiles, setSubImgFiles ] = useState([]);
    const fileId = useRef(1);
    const navigate = useNavigate();
    const [giveInputParams, setGiveInputParams] = useState({ 
        pageCategory: "기부",
        detailCategory : "아동",
        title: "",
        storyTitle: "",
        story: "",
        imgUrl: "",
        goalTotal: 0,
        endDate: "",
        giveUsing: [],
        donationExpense: [],
        businessStartDate: "",
        businessEndDate: "",
        target: "",
        targetCount: 0,
        benefitEffect: "",
        companyName: "",
        ceoName: "",
        companyAddress: "",
        companyPhoneNumber: "",
    });

    const [fundingInputParams, setFundingInputParams] = useState({ 
        pageCategory: "펀딩",
        detailCategory : "음식",
        title: "",
        storyTitle: "",
        story: "",
        imgUrl: "",
        goalTotal: 0,
        endDate: "",
        rewardName: [],
        rewardPrice: [],
        companyName: "",
        ceoName: "",
        nickname: "",
        companyAddress: "",
        companyPhoneNumber: "",
        email:""
    });

    const [ giveErrorMessages, giveFundErrorMessages ] = useState({
        title: "",
        storyTitle: "",
        story: "",
        mainImgUrl: "",
        subImgUrl: "",
        goalTotal: "",
        endDate: "",
        giveUsing: "",
        businessStartDate: "",
        businessEndDate: "",
        target: "",
        benefitEffect: "",
        companyName: "",
        ceoName: "",
        companyAddress: "",
        companyPhoneNumber: "",
    });

    const [ fundErrorMessages, setFundErrorMessages ] = useState({
        title: "",
        storyTitle: "",
        story: "",
        mainImgUrl: "",
        subImgUrl: "",
        goalTotal: "",
        endDate: "",
        rewardName: "",
        companyName: "",
        ceoName: "",
        nickname: "",
        companyAddress: "",
        companyPhoneNumber: "",
        email:""
    });
    
    const [giveTds, setGiveTds] = useState([{id: 1}]);
    
    const [rewardTds, setRewardTds] = useState([{id: 1}]);
    const giveId = useRef(2);
    const rewardId = useRef(2);
    const [showTable, setShowTable] = useState(true);
    const mainCategoryList = ["기부", "펀딩"];
    const giveSubCategoryList = ["아동","노인","장애인","다문화","환경"];
    const fundSubCateogoryList = ["음식", "도서", "의류", "액세서리&화장품", "꽃&과일", "생활용품"];

    const [giveUsingMap, setGiveUsingMap] = useState(new Map());
    const [giveUsingPriceMap, setGiveUsingPriceMap] = useState(new Map());

    const [rewardNameMap, setRewardNameMap] = useState(new Map());
    const [rewardPriceMap, setRewardPriceMap] = useState(new Map());

    const [rewardNameIsBlank, setRewarNameIsBlank] = useState(false);
    const [rewardPriceIsBlank, setRewarPriceIsBlank] = useState(false);

    const [giveUsingIsBlank, setGiveUsingIsBlank] = useState(false);
    const [givesingPriceIsBlank, setGiveUsingPriceIsBlank] = useState(false);

    const handleGivingUsingChange = (id, e) => {
        const newInputValues = new Map(giveUsingMap);
        newInputValues.set(id, e.target.value);
        setGiveUsingMap(newInputValues);
        if(e.target.value === "") {
            setGiveUsingIsBlank(false);
        }else {
            setGiveUsingIsBlank(true);
        }
    };

    const handleRewardNameChange = (id, e) => {
        const newInputValues = new Map(rewardNameMap);
        newInputValues.set(id, e.target.value);
        setRewardNameMap(newInputValues);
        if(e.target.value === "") {
            setRewarNameIsBlank(false);
        }else {
            setRewarNameIsBlank(true);
        }
    };

    const handleGivingUsingPriceChange = (id, e) => {
        const newInputValues = new Map(giveUsingPriceMap);
        newInputValues.set(id, parseInt(e.target.value));
        setGiveUsingPriceMap(newInputValues);
        if(e.target.value === "") {
            setGiveUsingPriceIsBlank(false);
        }else {
            setGiveUsingPriceIsBlank(true);
        }
      };

    const handleRewardPriceChange = (id, e) => {
        const newInputValues = new Map(rewardPriceMap);
        newInputValues.set(id, parseInt(e.target.value));
        setRewardPriceMap(newInputValues);
        if(e.target.value === "") {
            setRewarPriceIsBlank(false);
        }else {
            setRewarPriceIsBlank(true);
        }
      };

    const madeGiveUsingList = () => {
        const giveUsingList = Array.from(giveUsingMap.values())
        const giveUsingPriceList = Array.from(giveUsingPriceMap.values())

        if(!giveUsingIsBlank && !givesingPriceIsBlank) {
            alert("기부금 사용 계획은 비워져있으면 안 됩니다.");
        }else{
            setGiveInputParams({...giveInputParams, giveUsing: giveUsingList, donationExpense: giveUsingPriceList})
            setShowTable(false);
        }
    };

    const madeRewardList = () => {
        const nameList = Array.from(rewardNameMap.values())
        const priceList = Array.from(rewardPriceMap.values())

        if(!rewardNameIsBlank && !rewardPriceIsBlank) {
            alert("reward는 비워져있으면 안 됩니다.");
        }else{
            setFundingInputParams({...fundingInputParams, rewardName: nameList, rewardPrice: priceList})
            setShowTable(false);
        }
    };

    const addGiveUsingInputComponentHandle = () => {
        setGiveTds([...giveTds, {id: giveId.current}]);
        giveId.current += 1;
    }

    const addRewardInputComponentHandle = () => {
        setFundingInputParams({...fundingInputParams, showRewardTable: true});
        setRewardTds([...rewardTds, {id: rewardId.current}]);
        rewardId.current += 1;
    }

    const removeGiveUsingInputComponentHandle = (id,e) => {
        setGiveTds([...giveTds.filter(giveTd => giveTd.id !== parseInt(e.target.value))]);
        const newGiveUsing = new Map(giveUsingMap);
        const newGiveUsingPrice = new Map(giveUsingPriceMap);
        newGiveUsing.delete(id);
        newGiveUsingPrice.delete(id);
        setGiveUsingMap(newGiveUsing);
        setGiveUsingPriceMap(newGiveUsingPrice);
    }

    const removeRewardInputComponentHandle = (id,e) => {
        setRewardTds([...rewardTds.filter(rewardTd => rewardTd.id !== parseInt(e.target.value))]);
        const newRewardName = new Map(rewardNameMap);
        const newRewardPrice = new Map(rewardPriceMap);
        newRewardName.delete(id);
        newRewardPrice.delete(id);
        setRewardNameMap(newRewardName);
        setRewardPriceMap(newRewardPrice);
    }

      const changeGivePageCategory = (e) => {
        const givePageCategory = e.target.value;
        let giveDetailCategory = giveSubCategoryList.detailCategory;
      
        if (givePageCategory === "기부") {
            giveDetailCategory = "아동";
            setGiveInputParams({...giveInputParams, pageCategory: givePageCategory, detailCategory: giveDetailCategory})
        }else if(givePageCategory === "펀딩") {
            giveDetailCategory = "음식";
            setFundingInputParams({...fundingInputParams, pageCategory: givePageCategory, detailCategory: giveDetailCategory})
        }
      
        setGiveInputParams({...giveInputParams, pageCategory: givePageCategory, detailCategory: giveDetailCategory,});
      };

    const changeFundingPageCategory = (e) => {
        const fundingPageCategory = e.target.value;
        let fundingDetailCategory = fundSubCateogoryList.detailCategory;
    
        if (fundingPageCategory === "펀딩") {
            fundingDetailCategory = "음식";
            setFundingInputParams({...fundingInputParams, pageCategory: fundingPageCategory, detailCategory: fundingDetailCategory})
        }else if(fundingPageCategory === "기부") {
            fundingDetailCategory = "아동"
            setGiveInputParams({...giveInputParams, pageCategory: fundingPageCategory, detailCategory: fundingDetailCategory})
        }
    }

    const changeDetailCategory = (e) => {
        setGiveInputParams({...giveInputParams, detailCategory:e.target.value})
        setFundingInputParams({...fundingInputParams, detailCategory:e.target.value})
    }

    const changeTitle = (e) => {
        setGiveInputParams({...giveInputParams, title:e.target.value})
        setFundingInputParams({...fundingInputParams, title:e.target.value})
    }

    const changeStoryTitle = (e) => {
        setGiveInputParams({...giveInputParams, storyTitle:e.target.value})
        setFundingInputParams({...fundingInputParams, storyTitle:e.target.value})
    }

    const changeStory = (e) => {
        setGiveInputParams({...giveInputParams, story:e.target.value})
        setFundingInputParams({...fundingInputParams, story:e.target.value})
    }

    const changeMainImgUrl = (e) => {
        const newImgFiles = [];

        // 자바에서 쓰던 foreach에서 : 대신에 of를 쓴 것
        for(const file of e.target.files) {
            const fileData = {
                id: fileId.current,
                file
            }
            fileId.current += 1;
            newImgFiles.push(fileData)      
        }

        setMainImgFiles([newImgFiles[newImgFiles.length - 1]]);
    }

    const changeSubImgUrl = (e) => {
        const newImgFiles = [];

        for(const file of e.target.files) {
            const fileData = {
                id: fileId.current,
                file
            }
            fileId.current += 1;
            newImgFiles.push(fileData)      
        }

        setSubImgFiles([newImgFiles[newImgFiles.length - 1]]);
    }


    const changeGoalTotal = (e) => {
        const parsedGoalTotal = parseInt(e.target.value, 10);

        setGiveInputParams({...giveInputParams, goalTotal: parsedGoalTotal})
        setFundingInputParams({...fundingInputParams, goalTotal: parsedGoalTotal})
    }

    const changeEndDate = (e) => {
        setGiveInputParams({...giveInputParams, endDate:e.target.value})
        setFundingInputParams({...fundingInputParams, endDate:e.target.value})
    }

    const changeBusinessStartDate = (e) => {
        setGiveInputParams({...giveInputParams, businessStartDate:e.target.value})
    }

    const changeBusinessEndDate = (e) => {
        setGiveInputParams({...giveInputParams, businessEndDate:e.target.value})
    }

    const changeTarget = (e) => {
        setGiveInputParams({...giveInputParams, target:e.target.value})
    }

    const changeTargetCount = (e) => {
        setGiveInputParams({...giveInputParams, targetCount:e.target.value})
    }

    const changeBenefitEffect = (e) => {
        setGiveInputParams({...giveInputParams, benefitEffect:e.target.value})
    }

    const changeCompanyName = (e) => {
        setGiveInputParams({...giveInputParams, companyName:e.target.value})
        setFundingInputParams({...fundingInputParams, companyName:e.target.value})
    }

    const changeCeoName = (e) => {
        setGiveInputParams({...giveInputParams, ceoName:e.target.value})
        setFundingInputParams({...fundingInputParams, ceoName:e.target.value})
    }

    const changeNickname = (e) => {
        setFundingInputParams({...fundingInputParams, nickname:e.target.value})
    }

    const changeCompanyAddress = (e) => {
        setGiveInputParams({...giveInputParams, companyAddress:e.target.value})
        setFundingInputParams({...fundingInputParams, companyAddress:e.target.value})
    }

    const changePhoneNumber = (e) => {
        setGiveInputParams({...giveInputParams, companyPhoneNumber:e.target.value})
        setFundingInputParams({...fundingInputParams, companyPhoneNumber:e.target.value})
    }

    const changeEmail = (e) => {
        setGiveInputParams({...giveInputParams, email:e.target.value})
        setFundingInputParams({...fundingInputParams, email:e.target.value})
    }

```

</br>

- 카테고리를 변경할 때 마다 상태값이 바뀌게 펀딩이면 펀딩과 관련된 것들, 기부면 기부와 관련된 것들로 만들어줬다.

- 기부금 사용금액 추가와 리워드 추가하는 부분에서 Map으로 받아 리스트를 id로 추가와 제거를 할 수 있고, value로 값을 받을 수 있게 만들었다.

- 나머지는 input 창에 받은 값을 상태 업데이트를 해주고 있다.

- 이미지 파일을 새로운 배열에 받아주고, 이미지 상태값에 배열의 마지막 값만 업데이트 하도록 했다.

---

</br></br>

**요청**

```javascript

    const giveRegisterPage = async () => {
        const formData = new FormData();
        formData.append("pageCategory", giveInputParams.pageCategory);
        formData.append("detailCategory", giveInputParams.detailCategory)
        formData.append("title", giveInputParams.title)
        formData.append("storyTitle", giveInputParams.storyTitle)
        formData.append("story", giveInputParams.story)
        mainImgFiles.forEach(imgFile => {
            formData.append("mainImgUrl", imgFile.file);
        })
        subImgFiles.forEach(imgFile => {
            formData.append("subImgUrl", imgFile.file);
        })
        formData.append("goalTotal", giveInputParams.goalTotal);
        formData.append("endDate", giveInputParams.endDate);
        formData.append("giveUsing", giveInputParams.giveUsing);
        formData.append("donationExpense", giveInputParams.donationExpense);
        formData.append("businessStartDate", giveInputParams.businessStartDate);
        formData.append("businessEndDate", giveInputParams.businessEndDate);
        formData.append("target", giveInputParams.target);
        formData.append("targetCount", giveInputParams.targetCount);
        formData.append("benefitEffect", giveInputParams.benefitEffect);
        formData.append("companyName", giveInputParams.companyName)
        formData.append("ceoName", giveInputParams.ceoName)
        formData.append("companyAddress", giveInputParams.companyAddress)
        formData.append("companyPhoneNumber", giveInputParams.companyPhoneNumber)

        const option = {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        }
        try {
            await axios.post("http://localhost:8080/admin/giving/registerpage", formData, option)
            alert("기부 페이지 등록 성공");
            navigate("/giving");
        } catch (error) {
            giveFundErrorMessages({
                title: "",
                storyTitle: "",
                story: "",
                mainImgUrl: "",
                subImgUrl: "",
                endDate: "",
                giveUsing: "",
                businessStartDate: "",
                businessEndDate: "",
                target: "",
                benefitEffect: "",
                companyName: "",
                ceoName: "",
                companyAddress: "",
                companyPhoneNumber: "",
                ...error.response.data.errorData})
        }
    };

    const fundingRegisterPage = async () => {
        const formData = new FormData();
        formData.append("pageCategory", fundingInputParams.pageCategory);
        formData.append("detailCategory", fundingInputParams.detailCategory)
        formData.append("title", fundingInputParams.title)
        formData.append("storyTitle", fundingInputParams.storyTitle)
        formData.append("story", fundingInputParams.story)
        mainImgFiles.forEach(imgFile => {
            formData.append("mainImgUrl", imgFile.file);
        })
        subImgFiles.forEach(imgFile => {
            formData.append("subImgUrl", imgFile.file);
        })
        formData.append("goalTotal", fundingInputParams.goalTotal);
        formData.append("endDate", fundingInputParams.endDate);
        formData.append("rewardName", fundingInputParams.rewardName)
        formData.append("rewardPrice", fundingInputParams.rewardPrice)
        formData.append("companyName", fundingInputParams.companyName)
        formData.append("ceoName", fundingInputParams.ceoName)
        formData.append("nickname", fundingInputParams.nickname)
        formData.append("companyAddress", fundingInputParams.companyAddress)
        formData.append("companyPhoneNumber", fundingInputParams.companyPhoneNumber)
        formData.append("email", fundingInputParams.email)
        const option = {
            headers: {
                "Content-Type": "multipart/form-data",
                Authorization: `Bearer ${accessToken}`
            }
        }
        try {
            await axios.post("http://localhost:8080/admin/funding/registerpage", formData, option);
            alert("펀딩 페이지 등록 성공");
            navigate("/funding");
        } catch (error) {
            setFundErrorMessages({
                title: "",
                storyTitle: "",
                story: "",
                mainImgUrl: "",
                subImgUrl: "",
                endDate: "",
                rewardName: "",
                companyName: "",
                ceoName: "",
                nickname: "",
                companyAddress: "",
                companyPhoneNumber: "",
                email:""
                , ...error.response.data.errorData})
        }
    };

```

</br>

- 지금껏 json으로 요청을 보내왔지만 이미지가 들어간 값들을 요청을 보내려면 formdata로 받아서 보내야 한다. 그래서 FormData를 생성하고 값을 받아준 후 Content-Type에 form-data를 넣어주게 했다.

- 관리자만 등록이 가능하기 때문에 서버로 요청이 들어가면서 토큰으로 인증 단계를 거치게 된다.

---

</br></br>

## BackEnd

**Controller**

- 기부

```java

@RestController
@RequiredArgsConstructor
public class GiveRegisterController {

	private final GiveRegsterPageService giveRegsterPageService;
	
	@ValidAspect
	@PostMapping("/admin/giving/registerpage")
	public ResponseEntity<?> registerPage(@Valid GivingRegisterReqDto givingRegisterReqDto, BindingResult bindingResult) {
		giveRegsterPageService.giveRegisterPage(givingRegisterReqDto);
		return ResponseEntity.ok().body(true);
	}
	
}

```

</br>

- 펀딩

```java

@RestController
@RequiredArgsConstructor
public class FundingRegisterController {

	private final FundingRegisterPageService fundingRegisterPageService;

	@ValidAspect
	@PostMapping("/admin/funding/registerpage")
	public ResponseEntity<?> registerPage(@Valid FundingRegisterPageReqDto registerPageReqDto, BindingResult bindingResult) {
		fundingRegisterPageService.registerPage(registerPageReqDto);
		return ResponseEntity.ok().body(true);
	}

}

```

</br>

- 요청에 대한 인증이 끝나고 데이터를 Service로 넘긴다.

---

</br></br>

**Service**

- 기부

```java

@Service
@RequiredArgsConstructor
public class GiveRegsterPageService {
	
	private final GiveRegisterPageRepository giveRegisterPageRepository;
	private Center centerEntity;
	private GiveRegisterPage giveRegisterPageEntity;
	
	@Value("${file.path}")
	private String filePath;
	
	public int giveRegisterPage (GivingRegisterReqDto givingRegisterReqDto) {
		centerEntity = givingRegisterReqDto.toCenterEntity();
		giveRegisterPageRepository.toSaveCenter(centerEntity);
		
		giveRegisterPageEntity = givingRegisterReqDto.toGiveRegisterEntity(filePath);
		giveRegisterPageEntity.setCenterId(centerEntity.getCenterId());
		giveRegisterPageRepository.toSaveGiveRegisterPage(giveRegisterPageEntity);
		
		TargetBenefit targetBenefitEntity = givingRegisterReqDto.toTargetBenefitEntity();
		targetBenefitEntity.setGivingPageId(giveRegisterPageEntity.getGivingPageId());
		giveRegisterPageRepository.toSaveTarget(targetBenefitEntity);
		
		List<DonationUsePlan> donationEntity = givingRegisterReqDto.toDonationUsePlanEntity();
		donationEntity.forEach(donation -> {
			giveRegisterPageRepository.toSaveDonation(
			DonationUsePlan.builder()
			.pageCategory(donation.getPageCategory())
			.giveUsing(donation.getGiveUsing())
			.donationExpense(donation.getDonationExpense())
			.givingPageId(giveRegisterPageEntity.getGivingPageId())
			.build());
		});
		
		GivingSubImg givingSubImgEntity = givingRegisterReqDto.togivingSubImgEntity(filePath);
		givingSubImgEntity.setGivingPageId(giveRegisterPageEntity.getGivingPageId());
		return giveRegisterPageRepository.toSaveGivingSubImg(givingSubImgEntity);
	}

}

```

</br>

- 펀딩

```java

@Service
@RequiredArgsConstructor
public class FundingRegisterPageService {

	private final FundingRegisterPageRepository registerPageRepository;
	private FundingRegisterPage fundingRegisterEntity;
	
	@Value("${file.path}")
	private String filePath;
	
	
	public int registerPage(FundingRegisterPageReqDto registerPageReqDto) {
		fundingRegisterEntity = registerPageReqDto.toRegisterEntity(filePath);
		registerPageRepository.toSaveRegisterPage(fundingRegisterEntity);
		
		BusinessInfo businessInfoEntity = registerPageReqDto.toBusinessEntity();
		businessInfoEntity.setFundingId(fundingRegisterEntity.getFundingId());
		registerPageRepository.toSaveBusinessInfo(businessInfoEntity);
		
		List<Reward> rewardEntity = registerPageReqDto.toRewardEntity();
		rewardEntity.forEach(reward -> {
			registerPageRepository.toSaveReward(
					Reward.builder()
					.pageCategory(reward.getPageCategory())
					.rewardName(reward.getRewardName())
					.rewardPrice(reward.getRewardPrice())
					.fundingId(fundingRegisterEntity.getFundingId())
					.build());
		});
		
		FundingSubImg fundingSubImgEntity = registerPageReqDto.toFundingSubImgEntity(filePath);
		fundingSubImgEntity.setFundingId(fundingRegisterEntity.getFundingId());
		return registerPageRepository.toSaveFundingSubImg(fundingSubImgEntity);
	}
}

```

</br>

- Dto에서 Entity로 바꾸는 값을 받아 Repository로 데이터를 보낸다.

---

</br></br>

**파일 경로 설정**

- application.yml

```html

spring:
  servlet:
    multipart:
      max-file-size: 100MB
      max-request-size: 100MB

file:
  path: C:\aws_project\workspace\CrowdFunding-portfolio\Backend\crowdfunding\upload\

```

</br>

- 경로 접근 설정

```java

@Configuration
public class WebMvcConfig implements WebMvcConfigurer{

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		WebMvcConfigurer.super.addResourceHandlers(registry);
		registry.addResourceHandler("/image/**")
				.addResourceLocations("file:///" + filePath)
				.resourceChain(true)
				.addResolver(new PathResourceResolver() {
					@Override
					protected Resource getResource(String resourcePath, Resource location) throws IOException {
						resourcePath = URLDecoder.decode(resourcePath, StandardCharsets.UTF_8);
						return super.getResource(resourcePath, location);
					}
				});
	}
}

```

</br>

- 업로드할 수 있는 파일의 크기를 최대 100MB로 설정을 한다. 이 값을 초과할 경우 요청이 거부가 된다.

- 업로드할 파일 경로를 설정을 하는데, 우리는 upload 폴더 안에 파일을 업로드를 할 것이다.

- 외부에서 이미지 경로에 직접적으 접근을 못하도록 file:/// ~~ 라는 실제 경로를 /image/**로 바꿔줬다. 그래서 데이터를 받아온 html에 image를 받을 때

```html

<img css={img} src={`http://localhost:8080/image/main/${funding.mainImgUrl}`} />

```

이런 식으로 해준 것이다. funding.mainImgUrl의 값으로는 아래에서 설정해준 tempFileName이 들어가있다.

---

</br></br>

**Dto**

- 기부

```java

	public GiveRegisterPage toGiveRegisterEntity(String filePath) {
		MultipartFile file = mainImgUrl;
		if(file == null) {
			return null;
		}
		String originFileName = file.getOriginalFilename();
		String extension = originFileName.substring(originFileName.lastIndexOf("."));
		String tempFileName = UUID.randomUUID().toString().replaceAll("-", "") + extension;
		Path uploadPath = Paths.get(filePath + "main/" + tempFileName);	// 경로/post/UUID.jpg
	
		File f = new File(filePath + "main");
		if(!f.exists()) {
			f.mkdirs();
		}
		
		try {
			Files.write(uploadPath, file.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		return GiveRegisterPage.builder()
				.pageCategory(pageCategory)
				.detailCategory(detailCategory)
				.title(title)
				.storyTitle(storyTitle)
				.story(story)
				.goalTotal(goalTotal)
				.mainImgUrl(tempFileName)
				.endDate(endDate)
				.build();
	}
	
	public GivingSubImg togivingSubImgEntity(String filePath) {
		MultipartFile file = subImgUrl;
		if(file == null) {
			return null;
		}
		String originFileName = file.getOriginalFilename();
		String extension = originFileName.substring(originFileName.lastIndexOf("."));
		String tempFileName = UUID.randomUUID().toString().replaceAll("-", "") + extension;
		Path uploadPath = Paths.get(filePath + "sub/" + tempFileName);	// 경로/post/UUID.jpg
		File f = new File(filePath + "sub");
		if(!f.exists()) {
			f.mkdirs();
		}
		
		try {
			Files.write(uploadPath, file.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		return GivingSubImg.builder()
				.subImgUrl(tempFileName)
				.pageCategory(pageCategory)
				.build();
	}
	
	public Center toCenterEntity() {
		return Center.builder()
				.pageCategory(pageCategory)
				.centerName(companyName)
				.centerAddress(companyAddress)
				.centerPhoneNumber(companyPhoneNumber)
				.centerCeo(ceoName)
				.build();
	}
	
	public TargetBenefit toTargetBenefitEntity() {
		return TargetBenefit.builder()
				.pageCategory(pageCategory)
				.target(target)
				.targetCount(targetCount)
				.benefitEffect(benefitEffect)
				.businessStartDate(businessStartDate)
				.businessEndDate(businessEndDate)
				.build();
	}
	
	public List<DonationUsePlan> toDonationUsePlanEntity() {
	    List<DonationUsePlan> donationUsePlans = new ArrayList<>();
	    int size = Math.min(giveUsing.size(), donationExpense.size());
	    for (int i = 0; i < size; i++) {
	        String give = giveUsing.get(i);
	        int donation = donationExpense.get(i);
	        DonationUsePlan donationPlan = DonationUsePlan.builder()
	        		.pageCategory(pageCategory)
	        		.giveUsing(give)
	        		.donationExpense(donation)
	        		.build();
	        donationUsePlans.add(donationPlan);
	    }
	    return donationUsePlans;
	}

```

</br>

- 펀딩

```java

	public FundingRegisterPage toRegisterEntity(String filePath) {
		MultipartFile file = mainImgUrl;
		if(file == null) {
			return null;
		}
		String originFileName = file.getOriginalFilename();
		String extension = originFileName.substring(originFileName.lastIndexOf("."));
		String tempFileName = UUID.randomUUID().toString().replaceAll("-", "") + extension;
		Path uploadPath = Paths.get(filePath + "main/" + tempFileName);	// 경로/post/UUID.jpg
		System.out.println("filePath: " + filePath);
		File f = new File(filePath + "main");
		if(!f.exists()) {
			f.mkdirs();
		}
		
		try {
			Files.write(uploadPath, file.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return FundingRegisterPage.builder()
				.pageCategory(pageCategory)
				.detailCategory(detailCategory)
				.title(title)
				.storyTitle(storyTitle)
				.story(story)
				.goalTotal(goalTotal)
				.mainImgUrl(tempFileName)
				.endDate(endDate)
				.nickname(nickname)
				.build();
	}
	
	public BusinessInfo toBusinessEntity() {
		return BusinessInfo.builder()
				.pageCategory(pageCategory)
				.companyName(companyName)
				.ceoName(ceoName)
				.companyAddress(companyAddress)
				.companyPhoneNumber(companyPhoneNumber)
				.ceoEmail(email)
				.build();
	}
	

	public List<Reward> toRewardEntity() {
	    List<Reward> rewards = new ArrayList<>();
	    int size = Math.min(rewardName.size(), rewardPrice.size()); // 두 리스트 중 작은 크기를 선택

	    for (int i = 0; i < size; i++) {
	        String name = rewardName.get(i);
	        int price = rewardPrice.get(i);
	        Reward reward = Reward.builder()
	            .pageCategory(pageCategory)
	            .rewardName(name)
	            .rewardPrice(price)
	            .build();
	        rewards.add(reward);
	    }

	    return rewards;
	}
	
	public FundingSubImg toFundingSubImgEntity(String filePath) {
		MultipartFile file = subImgUrl;
		if(file == null) {
			return null;
		}
		String originFileName = file.getOriginalFilename();
		String extension = originFileName.substring(originFileName.lastIndexOf("."));
		String tempFileName = UUID.randomUUID().toString().replaceAll("-", "") + extension;
		Path uploadPath = Paths.get(filePath + "sub/" + tempFileName);	// 경로/post/UUID.jpg
		File f = new File(filePath + "sub");
		if(!f.exists()) {
			f.mkdirs();
		}
		
		try {
			Files.write(uploadPath, file.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		return FundingSubImg.builder()
				.subImgUrl(tempFileName)
				.pageCategory(pageCategory)
				.build();
	}
	

```

</br>

- 파일이 없는 경우 null을 반환한다.

- 업로드된 파일의 원본 파일 이름과 확장자를 추출한다. 확장자는 파일 이름에서 마지막 . 이후의 문자열로 추출된다.

- 임시 파일 이름을 생성하기 위해 UUID를 사용한다. UUID는 랜덤한 키값을 생성하는데 사용되며, 이것이 파일 이름에 포함된다. 문자열만 사용할 것이기에 UUID 안에 포함되어있는 "-"를 제거해준다.

- uploadPath는 업로드된 파일을 저장할 경로를 나타낸다. filePath 변수와 위에서 만들어준 임시 파일 이름을 결합하여 만들어준다.

- 파일을 저장할 디렉토리가 존재하지 않을 경우, 해당 디렉토리를 생성한다.

- Files.write(uploadPath, file.getBytes())는 실제로 파일을 저장하는 부분. uploadPath에 업로드된 파일의 byte를 사용한다.

- 데이터베이스에는 파일 이름만 존재하면 되기 때문에 tempFileName만 보내는 것.

- 나머지는 똑같이 Builder를 사용하여 값을 Entity에 넣어주고 있다.

---

</br></br>

**Repository**

- 기부

```java

@Mapper
public interface GiveRegisterPageRepository {
	public int toSaveCenter(Center center);
	public int toSaveGiveRegisterPage(GiveRegisterPage giveRegisterPage);
	public int toSaveDonation(DonationUsePlan donationUsePlan);
	public int toSaveTarget(TargetBenefit targetBenefit);
	public int toSaveGivingSubImg(GivingSubImg givingSubImg);
}

```

</br>

- 펀딩

```java

@Mapper
public interface FundingRegisterPageRepository {
	public int toSaveRegisterPage(FundingRegisterPage registerPage);
	public int registerPostsImgs(List<PostsImg> postsImgs);
	public int toSaveBusinessInfo(BusinessInfo businessInfo);
	public int toSaveReward(Reward reward);
	public int toSaveFundingSubImg(FundingSubImg fundingSubImg);
}

```

</br>

- Entity를 insert 하기 위해 둘 다 똑같이 보내고 있다. 성공 건수로 int 값을 반환.

--- 

**Sql**

- 기부

```sql

	<insert id="toSaveCenter"
		parameterType="com.webproject.crowdfunding.entity.Center"
		useGeneratedKeys="true"
		keyProperty="centerId">
		<if test="pageCategory == '기부'">
			insert into center_tb
			values
			(0, #{centerName}, #{centerAddress}, #{centerPhoneNumber}, #{centerCeo})
		</if>
	</insert>
	
	<insert id="toSaveGiveRegisterPage"
		parameterType="com.webproject.crowdfunding.entity.GiveRegisterPage"
		useGeneratedKeys="true"
		keyProperty="givingPageId">
				
	<if test="pageCategory == '기부' &amp;&amp; detailCategory == '아동'">
			insert into giving_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{centerId}, #{mainImgUrl}, 1)
	</if>
	<if test="pageCategory == '기부' &amp;&amp; detailCategory == '노인'">
			insert into giving_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{centerId}, #{mainImgUrl}, 2)
	</if>
	<if test="pageCategory == '기부' &amp;&amp; detailCategory == '장애인'">
			insert into giving_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{centerId}, #{mainImgUrl}, 3)
	</if>
	<if test="pageCategory == '기부' &amp;&amp; detailCategory == '다문화'">
			insert into giving_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{centerId}, #{mainImgUrl}, 4)
	</if>
	<if test="pageCategory == '기부' &amp;&amp; detailCategory == '환경'">
			insert into giving_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{centerId}, #{mainImgUrl}, 5)
	</if>
	</insert>
	  
	<insert id="toSaveTarget"
		parameterType="com.webproject.crowdfunding.entity.TargetBenefit"
		useGeneratedKeys="true"
		keyProperty="tbId">
		<if test="pageCategory == '기부'">
			insert into target_benefit_tb
			values
			(0, #{target}, #{targetCount}, #{benefitEffect}, #{businessStartDate}, #{businessEndDate}, #{givingPageId})
		</if>
	</insert>
	
	<insert id="toSaveDonation"
		parameterType="com.webproject.crowdfunding.entity.DonationUsePlan"
		useGeneratedKeys="true"
		keyProperty="dupId">
		<if test="pageCategory == '기부'">
			insert into donation_use_plan_tb
			values
			(0, #{giveUsing}, #{donationExpense}, #{givingPageId})
		</if>
	</insert>
	
	<insert id="toSaveGivingSubImg"
		parameterType="com.webproject.crowdfunding.entity.GivingSubImg"
		useGeneratedKeys="true"
		keyProperty="gpsiId">
		<if test="pageCategory == '기부'">
			insert into giving_page_sub_img_tb
			values
			(0, #{givingPageId}, #{subImgUrl})
		</if>	
	</insert>

```

</br>

- 펀딩

```sql

	<insert id="toSaveRegisterPage"
		parameterType="com.webproject.crowdfunding.entity.FundingRegisterPage"
		useGeneratedKeys="true"
		keyProperty="fundingId">
				
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '음식'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 1, #{nickname})
	</if>
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '도서'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 2, #{nickname})
	</if>
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '의류'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 3, #{nickname})
	</if>
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '액세서리&amp;화장품'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 4, #{nickname})
	</if>
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '꽃&amp;과일'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 5, #{nickname})
	</if>
	<if test="pageCategory == '펀딩' &amp;&amp; detailCategory == '생활용품'">
			insert into funding_page_tb
			values
			(0, #{title}, NOW(), #{endDate},  #{goalTotal}, #{storyTitle}, #{story}, #{mainImgUrl}, 6, #{nickname})
	</if>
	</insert>
	
	<insert id="toSaveBusinessInfo"
		parameterType="com.webproject.crowdfunding.entity.BusinessInfo"
		useGeneratedKeys="true"
		keyProperty="businessInfoId">
		<if test="pageCategory == '펀딩'">
			insert into business_info_tb
			values
			(0, #{companyName}, #{ceoName}, #{companyAddress}, #{companyPhoneNumber}, #{ceoEmail}, #{fundingId})
		</if>
	</insert>
	
	<insert id="toSaveReward"
		parameterType="com.webproject.crowdfunding.entity.Reward"
		useGeneratedKeys="true"
		keyProperty="rewardId">
		<if test="pageCategory == '펀딩'">
			insert into reward_tb
			values
			(0, #{rewardName}, #{rewardPrice}, #{fundingId})
		</if>
	</insert>
	
	<insert id="toSaveFundingSubImg"
		parameterType="com.webproject.crowdfunding.entity.FundingSubImg"
		useGeneratedKeys="true"
		keyProperty="fpsiId">
		<if test="pageCategory == '펀딩'">
			insert into funding_page_sub_img_tb
			values
			(0, #{fundingId}, #{subImgUrl})
		</if>
	</insert>

```

</br>

- 기부는 순서대로 사업자 정보, 기부 관련 정보, 사업대상효과 및 기대효과, 기부금 사용 계획, 상세 페이지에 쓸 서브 이미지로 insert를 하고 있다.

- 펀딩은 순서대로 펀딩 관련 정보, 사업자 정보, 리워드 정보, 상세 페이지에 쓸 서브 이미지로 insert를 하고 있다.

---

</br></br>

**Database**

- 기부 정보 등록

![기부 정보 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/c093f6a7-0350-4cdf-844f-347bb4d1062b)

</br>

- 기부 사업자 등록

![기부 사업자 정보 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/d205d248-d256-48c5-9c07-048c8131aea8)

</br>

- 기부 사업 계획 등록

![기부 사업 계획 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/453dd35f-eca7-4b45-911c-9bc9d38416fc)

</br>

- 기부 상세 이미지 등록

![기부 상세 이미지 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/353d3926-723f-4f2f-8165-98c172a7d65e)

</br>

- 기부금 사용 계획 등록

![기부금 사용 계획 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/f4d8ca92-0023-49f7-9d1a-703202ee726e)

</br>

---

- 펀딩 정보 등록

![펀딩 정보 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/fdb1d0fb-cab4-49d4-aaa0-60dd79896593)

</br>

- 펀딩 리워드 등록

![펀딩 리워드 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/a647d428-f1e6-4b43-9533-e7e89844abbe)

</br>

- 펀딩 사업자 정보 등록

![펀딩 사업자 정보 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/e3311a73-6ba8-4670-ad38-177f8e057941)

</br>

- 펀딩 상세 이미지 등록

![펀딩 상세 이미지 등록](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/733d00df-c950-4a92-8545-8e510a3d88f6)

</br>

- 이렇게 데이터베이스에 데이터가 잘 들어간 모습을 확인할 수 있다.

---

</div>
</details>

</br>

### **관리자 펀딩 및 기부 수정 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 수정</summary>
<div markdown="1">

![기부 수정 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/65ce4d46-6748-4936-bcba-4bd0ca3d5a26)

</div>
</details>

<details>
<summary>펀딩 수정</summary>
<div markdown="1">
  
![펀딩 수정 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/5c1ae2c5-038e-49be-8fbc-611f014ca421)

</div>
</details>

<details>
<summary>기부 & 펀딩 수정 코드 리뷰</summary>
<div markdown="1">
  
## FrontEnd

- 기부

```html

        {role ?
                <div css={adminContainer}>
                    <button css={givingModifyButton} onClick={adminModifyHandleSubmit}>기부 수정</button>
                    {modifyOpen ?
                        <div css={givingModifyContainer}>
                            <div css={givingIdentifyContainer}>
                                <div css={givingIdentifyMain}>
                                    <div css={givingModifyTitle}>기부 수정</div>
                                    <div css={modifyGivingHeader}>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>제목 수정</div>
                                            <input css={modifyValue} defaultValue={givingDetail.data.data.pageTitle} onChange={modifyHandle} name="givingName"/>
                                        </div>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>종료일 수정</div>
                                            <input css={modifyValue} onChange={modifyHandle} name="endDate"/>
                                        </div>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>목표 금액 수정</div>
                                            <input css={modifyValue} onChange={modifyHandle} name="goalTotal"/>
                                        </div>
                                    </div>
                                    <div css={modifyIdentifyButtonContainer}>
                                        <button css={modifyIdentifyButton} onClick={modifyIdentifyHandleSubmit}>확인</button>
                                        <button css={modifyCancelButton} onClick={modifyCancelHandleSubmit}>취소</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    : ""}
			: ""}

```

</br>

- 펀딩

```html

            {role ?
                <div css={adminContainer}>
                    <button css={fundingModifyButton} onClick={adminModifyHandleSubmit}>펀딩 수정</button>
                    {modifyOpen ?
                        <div css={joinFundContainer}>
                            <div css={joinFundIdentifyContainer}>
                                <div css={joinFundIdentifyMain}>
                                    <div css={FundingModifyTitle}>펀딩 수정</div>
                                    <div css={joinFundHeader}>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>제목 수정</div>
                                            <input css={modifyValue} defaultValue={funding.fundingTitle} onChange={modifyHandle} name="fundingName"/>
                                        </div>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>종료일 수정</div>
                                            <input css={modifyValue} onChange={modifyHandle} name="endDate"/>
                                        </div>
                                        <div css={modifyContainer}>
                                            <div css={modifyTitleTxt}>목표 금액 수정</div>
                                            <input css={modifyValue} onChange={modifyHandle} name="goalTotal"/>
                                        </div>
                                    </div>
                                    <div css={joinIdentifyButtonContainer}>
                                        <button css={joinIdentifyButton} onClick={modifyIdentifyHandleSubmit}>확인</button>
                                        <button css={joinCancelButton} onClick={modifyCancelHandleSubmit}>취소</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    : ""}
			: ""}

```

</br>

- role은 위 상세페이지 코드에서 유저 정보를 들고올 때 데이터가 ROLE_ADMIN이면 role이 true가 되고, 나머지는 false가 된다. 그래서 웹 상세페이지 상단에 관리자 계정만 보이게끔 기부 & 펀딩에 수정과 삭제를 넣었다.

- 이제 role이 true면 위와 같은 내용을 입력 받아서 처리를 할 수 있다. 

---

</br></br>

**입력 받은 값 처리**

- 기부

```javascript

    const modifyHandle = (e) => {
        const {name, value} = e.target
        setModify({...modify, [name]: value})
    }

```

</br>

```javascript

    const modifyHandle = (e) => {
        const {name, value} = e.target
        setModify({...modify, [name]: value})
    }

```

</br>

- 별 행동 없이 입력 받은 값을 상태 업데이트해준다.

---

</br></br>

**요청**

- 기부

```javascript

    const modifyInfo = useMutation(async () => {
        const data = {
            ...modify
        }

        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        return await axios.put("http://localhost:8080/admin/giving/modify", data, option)
    }, {
        enabled: refresh,

        onSuccess: () => {
            alert("기부 내용이 성공적으로 수정 되었습니다.");
            setRefresh(false);
            setModifyOpen(false);
        }
    })

```

</br>

- 펀딩

```javascript

    const modifyInfo = useMutation(async () => {
        const data = {
            ...modify
        }

        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        return await axios.put("http://localhost:8080/admin/funding/modify", data, option)
    }, {
        enabled: refresh,

        onSuccess: () => {
            alert("펀딩 내용이 성공적으로 수정 되었습니다.");
            setRefresh(false)
            setModifyOpen(false);
        }
    })

```

</br>

- 업데이트된 상태값들을 데이터베이스에 넣기 위해 요청을 보내고 있다.

- 수정이기 때문에 put 요청 사용.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequestMapping("/admin")
@RequiredArgsConstructor
public class AdminController {
	
	private final AdminService adminService;

	@PutMapping("/giving/modify")
	public ResponseEntity<?> givingModifyInfo(@RequestBody GivingModifyReqDto givingModifyReqDto) {
		return ResponseEntity.ok(adminService.givingModify(givingModifyReqDto));
	}

	@PutMapping("/funding/modify")
	public ResponseEntity<?> toFundingModify(@RequestBody FundingModifyReqDto fundingModifyReqDto) {
		return ResponseEntity.ok(adminService.fundingModify(fundingModifyReqDto));
	}

}

```

</br>

- 요청으로 받은 값들을 Service로 보내고 반환하고 있다.

- put 요청이 왔기 때문에 PutMapping 사용.

---

</br></br>

**Dto**

- 기부

```java

@Data
public class GivingModifyReqDto {
	private int givingPageId;
	private String givingName;
	private LocalDate endDate;
	private int goalTotal;
	
	public Giving givingModifyToEntity() {
		return Giving.builder()
				.pageId(givingPageId)
				.pageTitle(givingName)
				.endDate(endDate)
				.goalTotal(goalTotal)
				.build();
	}
}

```

</br>

- 펀딩

```java

@Data
public class FundingModifyReqDto {
	private int fundingId;
	private String fundingName;
	private LocalDate endDate;
	private int goalTotal;
	
	public Funding fundingToEntity() {
		return Funding.builder()
				.fundingId(fundingId)
				.fundingTitle(fundingName)
				.endDate(endDate)
				.goalTotal(goalTotal)
				.build();
	}
}

```

</br>

- 요청으로 받은 값을 Entity로 처리하고 있다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class AdminService {

	private final AdminRepository adminRepository;
	
	public int fundingModify(FundingModifyReqDto fundingModifyReqDto) {
		Funding fundingToEntity = fundingModifyReqDto.fundingToEntity();
		return adminRepository.saveFundingModify(fundingToEntity);
	}
	
	public int givingModify(GivingModifyReqDto givingModifyReqDto) {
		Giving givingEntity = givingModifyReqDto.givingModifyToEntity();
		return adminRepository.saveGivingModify(givingEntity);
	}

```

</br>

- Entity로 전환한 값들을 Repository로 넘기고 반환하고 있다. 수정도 성공 건수로 응답이 오기 때문에 int로 받는다.

---

</br></br>

**Repository**

```java

@Mapper
public interface AdminRepository {
	public int saveFundingModify(Funding funding);
	public int saveGivingModify(Giving giving);
}

```

</br>

- sql에서 update를 하기 위해 Entity를 보내고 있다. 마찬가지로 성공건수로 응답이 오기 때문에 int로 받고 있다.

---

</br></br>

**Sql**

```sql

	<update id="saveGivingModify">
		update
			giving_page_tb
		set
			giving_name = #{pageTitle},
			end_date = #{endDate},
			goal_total = #{goalTotal}
		where
			giving_page_id = #{pageId};
	</update>

	<update id="saveFundingModify">
		update
			funding_page_tb
		set
			funding_name = #{fundingTitle},
			end_date = #{endDate},
			goal_total = #{goalTotal}
		where
			funding_id = #{fundingId}
	</update>

```

</br>

- update문을 사용하여 수정할 데이터들을 넣어서 수정해주고 있다. 이제 성공적으로 데이터가 들어가면 수정이 된 것임.

---

</br></br>

**Database**

- 기부

![기부 수정](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/3a6a0808-3967-4894-9855-02b08aa53c91)

</br>

- 펀딩

![펀딩 수정](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/ba2b09ec-af50-49a7-9288-19a273c9c4e7)

</br>

- 이렇게 수정된 데이터들을 확인할 수 있다.

---

</div>
</details>

<br/>

### **관리자 펀딩 및 기부 삭제 화면 구현 영상 및 코드 리뷰**

<details>
<summary>기부 삭제</summary>
<div markdown="1">
  
![기부 삭제 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/91f9ff1a-73c5-4350-9682-3bfb66b8552d)

</div>
</details>

<details>
<summary>펀딩 삭제</summary>
<div markdown="1">
  
![펀딩 삭제 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/b0d12753-abce-45a6-9fa3-caca513d43f4)

</div>
</details>

<details>
<summary>기부 & 펀딩 삭제 코드 리뷰</summary>
<div markdown="1">

## FrontEnd

**관리자 삭제 html 코드**

- 기부

```html
        {role ?
		<button css={givingDeleteButton} onClick={adminDeleteHandleSubmit}>기부 삭제</button>
		{deleteOpen ?
		    <div css={givingDeleteContainer}>
			<div css={givingIdentifyContainer}>
			    <div css={givingIdentifyMain}>
				<div css={givingDeleteTitle}>기부 삭제</div>
				<div css={givingDeleteMessage}>기부를 정말 삭제 하시겠습니까?</div>
				<div css={givingDeleteButtonContainer}>
				    <button css={deleteIdentifyButton} onClick={deleteIdentifyHandleSubmit}>확인</button>
				    <button css={deleteCancelButton} onClick={deleteCancelHandleSubmit}>취소</button>
				</div>
			    </div>
			</div>
		    </div>
		: ""}
	: ""}

```

</br>

- 펀딩

```html
        {role ?
		<button css={fundingDeleteButton} onClick={adminDeleteHandleSubmit}>펀딩 삭제</button>
		{deleteOpen ?
		    <div css={joinFundContainer}>
			<div css={joinFundIdentifyContainer}>
			    <div css={joinFundIdentifyMain}>
				<div css={FundingModifyTitle}>펀딩 삭제</div>
				<div css={fundingDeleteMessage}>펀딩을 정말 삭제 하시겠습니까?</div>
				<div css={joinIdentifyButtonContainer}>
				    <button css={joinIdentifyButton} onClick={deleteIdentifyHandleSubmit}>확인</button>
				    <button css={joinCancelButton} onClick={deleteCancelHandleSubmit}>취소</button>
				</div>
			    </div>
			</div>
		    </div>
		: ""}
	: ""}

```

</br>

- 수정은 수정할 내용을 입력 받아서 업데이트해준 상태값을 요청으로 보냈지만 삭제는 따로 값을 처리해주지 않고 버튼을 누르는 순간 바로 삭제 요청이 날라가도록 만들었다. 

---

</br></br>

**요청**

- 기부

```javascript

    const deleteFunding = useMutation(async () => {
        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        }
        return await axios.delete(`http://localhost:8080/admin/giving/delete/${pageId}`, option)
    }, {
        onSuccess: () => {
            alert("기부 내용이 성공적으로 삭제 되었습니다.")
            navigate("/giving")
        }
    })

```

</br>

- 펀딩

```javascript

    const deleteIdentifyHandleSubmit = () => {
        const rewardIds = [];
        fundingDetailReward.data.data.rewardList.map(reward => 
            rewardIds.push(reward.rewardId)
        )

        deleteFunding.mutate({
            rewardIds: rewardIds,
            fundingId: pageId
        });
    }

    const deleteFunding = useMutation(async (deleteInfo) => {
        const option = {
            headers: {
                Authorization: `Bearer ${accessToken}`
            },
            data: deleteInfo
        }
        return await axios.delete("http://localhost:8080/admin/funding/delete", option)
    }, {
        onSuccess: () => {
            alert("펀딩 내용이 성공적으로 삭제 되었습니다.")
            navigate("/funding")
        }
    })

```

</br>

- 기부는 pageId(선택한 기부 페이지)만 필요하기 때문에 url에 pageId를 넣어서 보냈고, 펀딩은 rewardId가 필요하기 때문에 List로 받아서 요청 데이터에 넣어줬다.

- 관리자가 삭제하기 때문에 서버에서 token을 검사해야 한다. 그래서 요청 헤더에 넣어서 보냈다.

- 삭제 요청이기 때문에 delete 요청

- 삭제가 성공적으로 되면 메세지와 함께 기부와 펀딩 메인 페이지로 이동

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequestMapping("/admin")
@RequiredArgsConstructor
public class AdminController {
	
	private final AdminService adminService;

	@DeleteMapping("/funding/delete")
		public ResponseEntity<?> toFundingDelete(@RequestBody FundingDeleteReqDto fundingDeleteReqDto) {
		return ResponseEntity.ok(adminService.fundingDelete(fundingDeleteReqDto));
	}
	
	@DeleteMapping("/giving/delete/{pageId}")
	public ResponseEntity<?> givingDeleteInfo(@PathVariable int pageId) {
		return ResponseEntity.ok(adminService.givingDelete(pageId));
	}
	
}

```

</br>

- delete 요청이 와서 DeleteMapping사용

- 요청이 성공적으로 오면 Service로 넘기고 성공 건수 반환.

---

</br></br>

**Dto**

```java

@Data
public class FundingDeleteReqDto {
	private int fundingId;
	private List<Integer> rewardIds;
	
	public Funding deleteFundingIdToEntity() {
		return Funding.builder().fundingId(fundingId).build();
	}
	
	public List<Reward> deleteRewardIdToEntity() {
			List<Reward> rewards = new ArrayList<>();
			for(int i = 0; i < rewardIds.size(); i++) {
				int rewardId = rewardIds.get(i);
				Reward reward = Reward.builder()
				.rewardId(rewardId)
				.build();
				rewards.add(reward);
			}
		return rewards;
	}
}

```

</br>

- fundingId와 rewardId를 삭제할 때 sql문을 따로 작성해야 해서 나눠주었다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class AdminService {

	private final AdminRepository adminRepository;
	
	public int fundingDelete(FundingDeleteReqDto fundingDeleteReqDto) {
		Funding fundingEntity = fundingDeleteReqDto.deleteFundingIdToEntity();
		List<Reward> rewards = fundingDeleteReqDto.deleteRewardIdToEntity();
		adminRepository.saveDeleteRewardId(rewards);
		return adminRepository.saveDeleteFundingId(fundingEntity);
	}
	
	public int givingDelete(int pageId) {
		adminRepository.saveDeleteGivingDonationUsePlan(pageId);
		adminRepository.saveDeleteGivingTargetBenefit(pageId);
		return adminRepository.saveGivingDelete(pageId);
	}
	
	
}

```

</br>

- 펀딩은 Dto에서 처리해준 Id를, 기부는 다른 작업 없이 그대로 Id를 Repository로 넘기고 성공 건수를 반환하고 있다.  

---

</br></br>

**Repository**

```java

@Mapper
public interface AdminRepository {
	public int saveDeleteFundingId(Funding funding);
	public int saveDeleteRewardId(List<Reward> reward);
	public int saveGivingDelete(int pageId);
	public int saveDeleteGivingDonationUsePlan(int pageId);
	public int saveDeleteGivingTargetBenefit(int pageId);
}

```

</br>

- 펀딩은 삭제를 할 시에 펀딩 메인 정보들, 리워드, 펀딩한 사람들을 삭제할 것이다.

- 기부는 삭제를 할 시에 기부 메인 정보들, 기부금 사용 계획, 사업대상효과 및 기대효과, 기부한 사람들을 삭제할 것이다.

---

</br></br>

**Sql**

- 펀딩

```sql

	<delete id="saveDeleteFundingId" parameterType="com.webproject.crowdfunding.entity.Funding">
		delete
		from
			funding_page_tb
		where
			funding_id = #{fundingId};
	</delete>
	
	<delete id="saveDeleteRewardId" parameterType="com.webproject.crowdfunding.entity.Reward">
		  delete
		  from
		 	reward_tb
		  where
		  	reward_id in
	  <foreach collection="list" item="reward" open="(" separator="," close=")">
	    	#{reward.rewardId}
	  </foreach>
	</delete>

```

</br>

- 기부

```sql

	<delete id="saveGivingDelete">
		delete
		from
			giving_page_tb
		where
			giving_page_id = #{pageId}
	</delete>
	
	<delete id="saveDeleteGivingDonationUsePlan">
		delete
		from
			donation_use_plan_tb
		where
			giving_page_id = #{pageId}
	</delete>
	
	<delete id="saveDeleteGivingTargetBenefit">
		delete
		from
			target_benefit_tb
		where
			giving_page_id = #{pageId}
	</delete>


```

</br>

- 펀딩 각 테이블에 해당되는 Id를 삭제하고 있다. rewardId는 List로 들고왔기 때문에 foreach를 돌려 rewardId를 하나씩 꺼내 삭제를 하고 있다.

- 기부도 각 테이블에 해당되는 Id를 삭제하고 있다.

- 펀딩한 사람과 기부한 사람들 등 나머지는 해당 funding_id, reward_id, giving_page_id로 가장 중요한 메인 정보들이 사라지기 전에 지워야 할 것들을 trigger에 작성을 해놨다. 그 부분은 아래 Database 사진에 설명이 되어있다.

---

</br></br>

**Database**

- 기부 삭제

![기부 삭제](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/a442bd49-ede2-432a-8853-8361d68d9041)

</br>

- 펀딩 삭제
  
![펀딩 삭제](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/81849142-6c56-486d-bdfb-db807122eb9d)

</br>

---

- 기부한 사람 삭제

![기부한 사람 삭제 trigger](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/c4eb8713-b080-4782-bd0b-20604ac90cb0)

</br>

- 리워드, 사업자 정보 삭제

![리워드, 사업자 정보 삭제 trigger](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/8ff949a8-1c43-434a-a135-432492bc020e)

</br>

- 펀딩한 사람 삭제

![펀딩한 사람 삭제 trigger](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/254613fd-f3cb-44d9-ac9a-a8352ac2f0b4)

</br>

- old는 현재 테이블을 뜻한다. 기부 삭제 trigger는 giver_tb에 있는 giving_page_id와 현재 테이블인 giving_page_tb에 있는 giving_page_id와 일치하는 것을 삭제한다는 것을 의미한다. 이는 BEFORE DELETE 안에 작성이 되어있기 때문에 giving_page_tb에 있는 id가 삭제되기 전에 giver_tb에 있는 id를 삭제한다는 의미다.

- 나머지도 마찬가지로 똑같은 형식으로 작성하였다.

---

</div>
</details>

<br/>

### **OAuth2 회원가입 및 로그인 화면 구현 영상**

<details>
<summary>OAuth2 회원가입 및 로그인</summary>
<div markdown="1">
  
![OAuth2 회원가입 및 로그인 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/c2bebc58-65d9-4b68-adba-dc939e1d0883)

</div>
</details>

<br/>

### **OAuth2 Google, Kakao 계정 통합 화면 구현 영상**

<details>
<summary>OAuth2 계정 통합</summary>
<div markdown="1">
  
![OAuth2 계정 통합 - Clipchamp로 제작](https://github.com/KORIT-KLJK/CrowdFunding-portfolio/assets/121987405/478e6782-37a1-4e0b-b352-fcbd70c0b817)


</div>
</details>

</br>

### OAuth2 회원가입, 로그인, 계정 통합 코드 리뷰

<details>
<summary>OAuth2 회원가입 및 로그인 코드 리뷰</summary>
<div markdown="1">

</br>
  
코드 리뷰하기에 앞서 구글, 네이버, 카카오 디벨로퍼 설정을 해줘야 한다. 예시로 구글 디벨로퍼 설정 방법을 아래에 작성을 해보겠다.

</br>

구글창에 구글 클라우드 플랫폼 검색 -> 두 번째 거 들어가기 -> 프로젝트 검색 -> 새프로젝트 -> 만들기 -> 방금 만들어진 프로젝트 선택 -> API 및 서비스 -> oauth 동의화면 -> 외부 -> 만들기 -> 앱 정보, 개발자 연락처 정보 입력 -> 저장 후 계속 -> 범위 추가(scope 설정) ->

(.../auth/userinfo.email	기본 Google 계정의 이메일 주소 확인	

 .../auth/userinfo.profile	개인정보(공개로 설정한 개인정보 포함) 보기)

두 개 선택 -> 저장 후 계속 -> 사용자 인증 정보 -> 사용자 인증 정보 만들기 -> OAuth 클라이언트 ID 만들기 -> 웹 애플리케이션 -> 이름 설정 -> 승인된 리디렉션 URI에 http://localhost:8080 -> 만들기 (클라이언트 보안 비밀번호는 보안 key이기 때문에 유출이 되면 안 됨) -> 서버를 만들 때 넣어줘야 할 Dependency

OAuth2 Client SECURITYSpring Boot integration for Spring Security's OAuth2/OpenID Connect client features.

</br>

여기까지 하면 구글 서버로 들어가기 위한 설정은 끝났다. 이제 코드 작성을 해보겠다.

## FrontEnd

**html 코드**

```html

    <div css={signupAndOtherLogin}>
	<div css={signupNaviBtn} onClick={signupNavi}>회원가입</div>
	<div css={providerLoginContainer}>다른 계정으로 로그인</div>
    </div>
	<div css={providerButtonContainer}>
	    <button css={google} onClick={googleAuthLoginClickHandle}><FcGoogle /></button>
	    <button css={naver} onClick={naverAuthLoginClickHandle}><SiNaver /></button>
	    <button css={kakao} onClick={kakaoAuthLoginClickHandle}><SiKakao /></button>
	</div>

```

</br>

- 구글, 네이버, 카카오 아이콘을 받아서, 클릭시 해당 계정으로 넘어감.

---

</br></br>

**로그인**

```javascript

    const googleAuthLoginClickHandle = () => {
        window.location.href = "http://localhost:8080/oauth2/authorization/google";
    }

    const naverAuthLoginClickHandle = () => {
        window.location.href = "http://localhost:8080/oauth2/authorization/naver";
    }

    const kakaoAuthLoginClickHandle = () => {
        window.location.href = "http://localhost:8080/oauth2/authorization/kakao";
    }

```

</br>

- http://localhost:8080/oauth2/authorization/google 이 주소는 구글 서버 주소임. naver면 젤 끝에 naver. kakao면 kakao

---

</br></br>

## BackEnd

**application.yml**

```html

  security:
    oauth2:
      client:
        registration:
          google:
            client-id: 360072367742-ej55vbhnd46b5gavi86k4n4bqaeki8hs.apps.googleusercontent.com
            client-secret: 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
            scope:
              - email
              - profile
          kakao:
            client-id: 78fef42274ba4dd840ab1be7626ef03f
            client-secret: Nc9PTT0EZZrBBac1KUacD1hgvEDSrh6S
            redirect-uri: http://localhost:8080/login/oauth2/code/kakao
            authorization-grant-type: authorization_code
            client-authentication-method: POST
            client-name: Kakao
            scope:
              - profile_nickname
              - account_email
          naver:
            client-id: A0GjFzJY3Z6ALBlxgYpS
            client-secret: RoEJ5AdEP7
            redirect-uri:  http://localhost:8080/login/oauth2/code/naver
            authorization-grant-type: authorization_code
            scope:
              - name
              - email
        provider:
          kakao:
            authorization-uri: https://kauth.kakao.com/oauth/authorize
            token-uri: https://kauth.kakao.com/oauth/token
            user-info-uri: https://kapi.kakao.com/v2/user/me
            user-name-attribute: id
          naver:
            authorization-uri: https://nid.naver.com/oauth2.0/authorize
            token-uri: https://nid.naver.com/oauth2.0/token
            user-info-uri: https://openapi.naver.com/v1/nid/me
            user-name-attribute: response

```

</br>

- client-id와 secret은 위에서 설명한 디벨로퍼를 만들고나면 나와있다. 거기에 있는 걸 붙여넣으면 된다.

- scope는 마찬가지로 위에서 설명한 scope 2개가 포함된다.

- 구글 서버에서 받은 토큰 안에는 provider가 포함되어있기 때문에 kakao와 naver처럼 따로 설정해줄 필요가 없다.

---

</br></br>

**SecurityConfig(웹 보안 설정)**

```java

public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	private final JwtTokenProvider jwtTokenProvider;
	private final OAuth2SuccessHandler oAuth2SuccessHandler;
	private final OAuth2Service oAuth2Service;
	private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
	
	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.cors();
		http.csrf().disable();
		http.httpBasic().disable();
		http.formLogin().disable();
		
		http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
		
		http.authorizeRequests()
			.antMatchers("/image/**", "/funding/**", "/giving/**", "/main/**", "/page/**")
			.permitAll()
			.antMatchers("/auth/funding/**", "/auth/giving/**", "/admin/**")
			.authenticated()
			.and()
			.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class)
			.exceptionHandling()
			.authenticationEntryPoint(jwtAuthenticationEntryPoint)
			.and()
			.oauth2Login()
			.loginPage("http://localhost:3000/auth/login")
			.successHandler(oAuth2SuccessHandler)
			.userInfoEndpoint()
			.userService(oAuth2Service);	
			
		
	}
}

```

</br>

- OAuth2 로그인 요청이 서버로 들어오면 가장 먼저 여기로 들어온다. 여기 중에서도 oauth2Login()으로 들어오게 되는데 이는 OAuth2 로그인 설정을 구성하는 단계다.

- loginPage("http://localhost:3000/auth/login")로 로그인 페이지 URL 설정한다. 우리는 http://localhost:3000/auth/login로 쓰고 있기 때문에 이렇게 설정을 해준 것이다.

- 그 다음 successHandler는 OAuth2 로그인이 성공적으로 됐을 때 실행이 되기 때문에 이 부분은 마지막에 실행이 된다. 그래서 다음으로는 userService로 가게 된다.

---

</br></br>

**OAuth2Service**

```java

@Service
@RequiredArgsConstructor
public class OAuth2Service implements OAuth2UserService<OAuth2UserRequest, OAuth2User>{

	@Override
	public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
		OAuth2UserService<OAuth2UserRequest, OAuth2User> oAuth2UserService = new DefaultOAuth2UserService();
		OAuth2User oAuth2User = oAuth2UserService.loadUser(userRequest);
		
		String registrationId = userRequest.getClientRegistration().getRegistrationId();
		
		OAuth2Attribute oAuth2Attribute = OAuth2Attribute.of(registrationId, oAuth2User.getAttributes());
		
		Map<String, Object> attributes = oAuth2Attribute.convertToMap();
		
		return new DefaultOAuth2User(Collections.singleton(new SimpleGrantedAuthority("ROLE_USER")), attributes, "email");
	}
}

```

</br>

- oAuth2UserService와 oAuth2User는 OAuth2 인증을 통해 유저 정보를 가져오는 과정을 처리하는 부분이다. 즉, 구글에서 발급 받은 토큰을 열어서 유저 정보를 가져오는 것이다.

- registrationId는 google, naver, kakao 중 어떤 것인지 찾는 것이다.

- oAuth2Attribute는 여러가지 정보들이 있는데 그 중 provider(google, naver, kakao)와 이름, 이메일을 들고오기 위해서 만들었다. 자세한 건 아래 코드에서 다룰 것이다.

- oAuth2Attribute 안에 convertToMap을 호출하면 바로 위에서 얘기한 3가지 정보를 들고올 수 있다.

- return하는 생성자 안에는 사용자의 권한, 속성, 고유 식별자를 들고 오는데, 식별자에 email이 들어간 이유는 말 그대로 고유한 식별자여야 하기 때문에 닉네임을 사용할 경우 중복이 될 수 있다. 그래서 email을 사용했다.

- 여기까지 성공하면 로그인을 위해 마지막으로 SuccessHandler로 가게 된다.

---

</br></br>

**OAuth2Attribute**

```java

@ToString
@Builder(access = AccessLevel.PRIVATE)	// 생성자 자체가 private이 됨
@Getter
public class OAuth2Attribute {
	// attribute 정보를 아래 3개로 통일을 시킴
    private Map<String, Object> attributes;
    private String email;
    private String name;
    private String provider;

    public static OAuth2Attribute of(String provider, Map<String, Object> attributes) {
        switch (provider) {
            case "google":
                return ofGoogle(provider, attributes);
            case "kakao":
                return ofKakao(provider, attributes);
            case "naver":
                return ofNaver(provider, attributes);
            default:
                throw new RuntimeException();
        }
    }

    // google, kakao, naver를 나눈 이유는 세 개 다 attribute의 구조가 다르다
    // google은 attribute 안에 내용이 다 들어 있음.
    private static OAuth2Attribute ofGoogle(String provider, Map<String, Object> attributes) {
        return OAuth2Attribute.builder()
                .name((String) attributes.get("name"))
                .email((String) attributes.get("email"))
                .provider((String) provider)
                .attributes(attributes)
                .build();
    }

    // map 안에 map이 있음
    private static OAuth2Attribute ofKakao(String provider, Map<String, Object> attributes) {
        Map<String, Object> kakaoAccount = (Map<String, Object>) attributes.get("kakao_account");
        Map<String, Object> kakaoProfile = (Map<String, Object>) kakaoAccount.get("profile");

        return OAuth2Attribute.builder()
                .name((String) kakaoProfile.get("nickname"))
                .email((String) kakaoAccount.get("email"))
                .provider((String) provider)
                .attributes(kakaoAccount)
                .build();
    }

    private static OAuth2Attribute ofNaver(String provider, Map<String, Object> attributes) {
        Map<String, Object> response = (Map<String, Object>) attributes.get("response");

        return OAuth2Attribute.builder()
                .name((String) response.get("name"))
                .email((String) response.get("email"))
                .provider((String) provider)
                .attributes(response)
                .build();
    }

    public Map<String, Object> convertToMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("name", name);
        map.put("email", email);
        map.put("provider", provider);

        return map;
    }
}

```

</br>

- of 메서드에는 위 서비스에서 매개변수로 전달 받은 provider와 유저 정보가 들어오게 된다. switch문으로 provider 해당되는 값을 찾아 그 메서드로 return을 한다. 지금은 구글로 진행하고 있기 때문에 ofGoogle로 가보겠다.

- 위 코드에서 달아준 주석처럼 google은 attribute 안에 내용이 다 들어 있다. 매개변수로 전달 받은 유저 정보들을 열어서 닉네임, 이메일, provider를 가지고 Builder를 통해 이 객체에 있는 변수에다 값을 넣어준다.

- Builder를 통해 변수에 값을 넣어주었기 때문에 마지막 convertToMap 함수에서 map으로 key와 value로 사용이 가능하다. 그래서 Service에서 convertToMap을 호출했을 때 이 3가지 정보가 들어가게 된 것이다.

---

</br></br>

**SuccessHandler**

```java

@Component
@RequiredArgsConstructor
public class OAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler{
	private final UserRepository userRepository;
	private final JwtTokenProvider jwtTokenProvider;	
	
	@Override
	public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws IOException, ServletException {
		OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
		String email = oAuth2User.getAttribute("email");
		String provider = oAuth2User.getAttribute("provider");
		User userEntity = userRepository.findUserByEmail(email);
		
		if(userEntity == null) {
			String registerToken = jwtTokenProvider.generateToken(authentication).getAccessToken().toString();
			String name = oAuth2User.getAttribute("name");
			response
			.sendRedirect(
					"http://localhost:3000/auth/oauth2/signup"
							+ "?registerToken=" + registerToken
							+ "&email=" + email
							+ "&name=" + URLEncoder.encode(name, "UTF-8")
							+ "&provider=" + provider
			);
		}else {
			if(StringUtils.hasText(userEntity.getProvider())) {
				if(!userEntity.getProvider().contains(provider)) {
					response.sendRedirect(
							"http://localhost:3000/auth/oauth2/merge"
					 			 	+ "?provider=" + provider
									+ "&email=" + email);
					return;
				}
				
				response.sendRedirect("http://localhost:3000/auth/oauth2/login"
				 			 	+ "?accessToken=" + jwtTokenProvider.generateToken(authentication).getAccessToken());
				
			}else {
				response.sendRedirect(
						"http://localhost:3000/auth/oauth2/merge"
				 			 	+ "?provider=" + provider
								+ "&email=" + email);
			}
		}
		
	}
}

```

</br>

- 이메일을 통해 데이터베이스에서 해당 유저 정보를 조회한다.

- 유저가 처음으로 로그인하는 경우 회원 가입 페이지로 리다이렉트를 하고, 인증 토큰과 함께 필요한 정보들을 전달한다. 여기서 리다이렉트란, 서버가 클라이언트에게 특정 URL로 이동하도록 요청하는 것을 말한다.

- 이미 가입한 사용자인 경우 provider 정보를 확인하여 이미 연동된 provider인지를 판단한다. 이미 연동된 provider라면 로그인 페이지로 리다이렉트하고, 새로운 인증 토큰을 발급한다. 아직 연동되지 않은 provider라면 provider 연동 페이지로 리다이렉트한다.

---

</br>

**OAuth2 로그인 리다이렉트**

```javascript

const OAuth2Login = () => {
    const [ searchParams, setSearchParams ] = useSearchParams();
    const accessToken = searchParams.get("accessToken");

    if(!!accessToken) {
        localStorage.setItem("accessToken", accessToken);
        window.location.replace("/");
    }

    return (
        <>
        
        </>
    );
};

```

</br>

- 서버에서 보낸 리다이렉트 URL에서 토큰을 가져온다. 그 토큰이 존재한다면 loalStorage에 토큰을 넣어주고, 메인 화면으로 보낸다. 여기까지 OAuth2 로그인 성공.

---

</div>
</details>

<details>
<summary>OAuth2 회원가입</summary>
<div markdown="1">
  
</br>

형식은 일반 회원가입이랑 완전 똑같으나 다른 점은 리다이렉트로 받은 URL을 열어 임시 토큰, 이메일, 이름, provider를 들고온다.

</br>

```javascript

    const [ searchParams, setSearchParams ] = useSearchParams();
    const registerToken = searchParams.get("registerToken");
    const email = searchParams.get("email");
    const name = searchParams.get("name");
    const provider = searchParams.get("provider");

```

</br>

```html

                                <FormControl variant="standard">
                                        <Input id="input-with-icon-adornment"
                                            css={placeholderFontSize}
                                            label="email" 
                                            variant="outlined" 
                                            value={email}
                                            disabled={true}
                                            type="text" 
                                            startAdornment={
                                                <InputAdornment position="start">
                                                <Mail />
                                                </InputAdornment>
                                            } />
                                    </FormControl>

                                    <FormControl variant="standard">
                                            <Input id="input-with-icon-adornment" 
                                                label="name" 
                                                variant="outlined" 
                                                type="text"
                                                value={name}
                                                disabled={true}
                                                startAdornment={
                                                    <InputAdornment position="start">
                                                    <Badge />
                                                    </InputAdornment>
                                                } />
                                            {errorMessage.name && <Alert css={errorCss} severity="error">{errorMessage.name}</Alert>}
                                    </FormControl>

```

</br>

- 이처럼 이메일과 이름을 들고와서 바꾸지 못하게 disabled를 걸어준다.

---

</br></br>

**요청**

```javascript

    const OAuth2register = useMutation(async () => {
        if (signUp.password !== signUp.confirmPassword) {
            setErrorMessages({confirmPassword: "비밀번호가 일치하지 않습니다."});
            return;
        }
        const data = {
            ...signUp, ...address
        }

        const option = {
            headers: {
                registerToken: `Bearer ${registerToken}`,
                "Content-Type": "application/json"
            }
        }
        try {
            await axios.post("http://localhost:8080/auth/oauth2/signup", JSON.stringify(data), option)
            setErrorMessages({password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "", zonecode: "", address: "", detailAddress: ""})
            alert("회원가입 완료")
            window.location.replace("/login")
        }catch(error) {
            console.log(error)
            setErrorMessages({password: "", confirmPassword: "", name: "", gender: "", birthday: "", phoneNumber: "", zonecode: "", address: "", detailAddress: "",...error.response.data.errorData})
        }
    });

```

</br>

- 요청 데이터에 추가된 것은 provider 하나밖에 없다.

- 일반 회원가입 양식이랑 똑같은 것을 확인할 수 있다. 서버에 임시 토큰을 헤더로 보내서 OAuth2로 들어온 건지 확인을 할 것이다.

---

</br></br>

## BackEnd

**Controller**

```java

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class OAuth2Controller {

	private final JwtTokenProvider jwtTokenProvider;
	private final OAuth2Service oAuth2Service;
	
	
	
	@PostMapping("/oauth2/signup")
	@ValidAspect
	public ResponseEntity<?> signup(
			@RequestHeader(value="registerToken") String registerToken,
			@Valid
			@RequestBody OAuth2SignUpReqDto oAuth2SignUpReqDto,
			BindingResult bindingResult) {
		boolean validated = jwtTokenProvider.validateToken(jwtTokenProvider.getToken(registerToken));
		
		if(!validated) {
			// 토큰이 유효하지 않음.
			return ResponseEntity.badRequest().body("회원가입 요청 시간이 초과하였습니다.");
		}
		return ResponseEntity.ok().body(oAuth2Service.oauth2signUp(oAuth2SignUpReqDto));
	}
 }

```

</br>

- 토큰 인증하는 함수를 호출해서 임시 토큰을 넣어준 다음 인증을 한다. 토큰이 유효하지 않을 경우 badRequest로 처리했다.

- OAuth2 인증이 되면 Service로 넘어간다.

- Dto는 일반 회원가입 형식이랑 동일한데 provider 변수만 추가를 했다.

---

</br></br>

**Service**

```java

@Service
@RequiredArgsConstructor
public class OAuth2Service implements OAuth2UserService<OAuth2UserRequest, OAuth2User>{

	public int oauth2signUp(OAuth2SignUpReqDto oAuth2RegisterReqDto) {
		userEntity = oAuth2RegisterReqDto.toUserEntity();
		userRepository.signUpUser(userEntity);
		userRepository.saveAuthority(
				Authority.builder()
				.userId(userEntity.getUserId())
				.roleId(1)
				.build()
			);
		
		Address addressEntity = oAuth2RegisterReqDto.toAddressEntity();
		addressEntity.setUserId(userEntity.getUserId());
		return userRepository.saveAddress(addressEntity);
	}
}

```

</br>

- 일반 회원가입이랑 동일하게 작성했다.

---

</br></br>

**Repository**

```java

@Mapper
public interface UserRepository {
	public int saveAddress(Address address);
	public int signUpUser(User user);
}

```

</br>

- Repository도 마찬가지

---

</br></br>

**Sql**

```sql

	<insert id="signUpUser"
		parameterType="com.webproject.crowdfunding.entity.User"
		useGeneratedKeys="true"
		keyProperty="userId">
		insert into user_tb
		values(0, #{email}, #{password}, #{name}, #{birthday}, #{gender}, #{provider}, #{phoneNumber})
	</insert>
	
	<insert id="saveAuthority" parameterType="com.webproject.crowdfunding.entity.Authority">
		insert into authority_tb
		values
			(0, #{userId}, #{roleId})
	</insert>

```

</br>

- values에 provider가 들어가있는 걸 확인할 수 있다. provider는 null일 수 있기 때문에 table을 만들 때 provider는 not null 체크를 하지 않았다.

---

**Database**


![OAuth2 회원가입](https://github.com/iuejeong/-AWS-_Java_study_202212_euihyun/assets/121987405/bd118735-2490-4615-85bb-18a7ba5358d0)

</br>

- 이렇게 provider가 있는 것과 없는 것을 확인할 수 있다.

---

</div>
</details>

<details>
<summary>OAuth2 계정 통합</summary>
<div markdown="1">



</div>
</details>
